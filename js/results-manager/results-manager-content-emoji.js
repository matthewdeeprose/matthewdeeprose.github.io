/**
 * @module EmojiContentProcessor
 * @description Processes emoji shortcodes and converts them to accessible emoji representations
 */
import { ContentProcessorBase } from "./results-manager-content-base.js";

export class EmojiContentProcessor extends ContentProcessorBase {
  // Logging configuration (within class scope)
  static LOG_LEVELS = {
    ERROR: 0,
    WARN: 1,
    INFO: 2,
    DEBUG: 3,
  };

  static DEFAULT_LOG_LEVEL = EmojiContentProcessor.LOG_LEVELS.WARN;
  static ENABLE_ALL_LOGGING = false;
  static DISABLE_ALL_LOGGING = false;

  /**
   * Create a new EmojiContentProcessor instance
   */
  constructor() {
    super();

    // Initialise logging configuration for this instance
    this.currentLogLevel = EmojiContentProcessor.DEFAULT_LOG_LEVEL;
    this.allLoggingEnabled = EmojiContentProcessor.ENABLE_ALL_LOGGING;
    this.allLoggingDisabled = EmojiContentProcessor.DISABLE_ALL_LOGGING;

    this.logInfo("üöÄ EmojiContentProcessor: Initialising emoji processor");

    // Set fallback map immediately
    this.emojiMap = this.getFallbackEmojiMap();

    // Add a flag to track if we're using fallback
    this.usingFallback = true;
    this.initialized = true; // Mark as initialised immediately with fallback

    this.logInfo(
      "üîÑ EmojiContentProcessor: Starting async loading of emoji data file"
    );
    this.initializeAsync();

    this.utils.log(
      "Emoji content processor initialised with fallback emoji map"
    );
  }

  /**
   * Check if logging should occur for the given level
   * @param {number} level - The logging level to check
   * @returns {boolean} True if logging should occur
   */
  shouldLog(level) {
    if (this.allLoggingDisabled) return false;
    if (this.allLoggingEnabled) return true;
    return level <= this.currentLogLevel;
  }

  /**
   * Log an error message
   * @param {string} message - The message to log
   * @param {*} [data] - Optional data to log
   */
  logError(message, data = null) {
    if (this.shouldLog(EmojiContentProcessor.LOG_LEVELS.ERROR)) {
      if (data) {
        console.error(message, data);
      } else {
        console.error(message);
      }
    }
  }

  /**
   * Log a warning message
   * @param {string} message - The message to log
   * @param {*} [data] - Optional data to log
   */
  logWarn(message, data = null) {
    if (this.shouldLog(EmojiContentProcessor.LOG_LEVELS.WARN)) {
      if (data) {
        console.warn(message, data);
      } else {
        console.warn(message);
      }
    }
  }

  /**
   * Log an info message
   * @param {string} message - The message to log
   * @param {*} [data] - Optional data to log
   */
  logInfo(message, data = null) {
    if (this.shouldLog(EmojiContentProcessor.LOG_LEVELS.INFO)) {
      if (data) {
        console.log(message, data);
      } else {
        console.log(message);
      }
    }
  }

  /**
   * Log a debug message
   * @param {string} message - The message to log
   * @param {*} [data] - Optional data to log
   */
  logDebug(message, data = null) {
    if (this.shouldLog(EmojiContentProcessor.LOG_LEVELS.DEBUG)) {
      if (data) {
        console.log(message, data);
      } else {
        console.log(message);
      }
    }
  }

  /**
   * Initialize the emoji map asynchronously
   * This loads the emoji data from the JSON file
   */
  async initializeAsync() {
    try {
      this.logDebug(
        "üîç EmojiContentProcessor: Starting to load emoji data from JSON file"
      );

      // Change the path to make it more likely to find the file
      const emojiPath = "/emoji-data.json"; // Try absolute path
      this.logDebug(
        `üìÇ EmojiContentProcessor: Attempting to load from: ${emojiPath}`
      );

      // Add logging before fetch to clearly track execution
      this.logDebug("üîÑ EmojiContentProcessor: About to fetch emoji data...");

      // Fetch with explicit timeout and error handling
      const response = await fetch(emojiPath, {
        method: "GET",
        cache: "no-cache",
        timeout: 5000,
      });

      // Log response status
      this.logDebug(
        `üìÑ EmojiContentProcessor: Fetch response status: ${response.status}`
      );

      if (!response.ok) {
        this.logError(
          `‚ùå EmojiContentProcessor: Failed to load emoji data: ${response.status} ${response.statusText}`
        );
        throw new Error(
          `Failed to load emoji data: ${response.status} ${response.statusText}`
        );
      }

      this.logInfo(
        "‚úÖ EmojiContentProcessor: Emoji data file fetched successfully, parsing JSON..."
      );
      const data = await response.json();

      // Extract metadata if it exists
      if (data.__meta) {
        const { version, lastUpdated, totalCount } = data.__meta;
        this.logInfo(
          `üìä EmojiContentProcessor: Emoji data loaded - Version: ${version}, Last Updated: ${lastUpdated}, Total Emojis: ${totalCount}`
        );
        this.utils.log("Emoji data loaded", {
          version,
          lastUpdated,
          totalCount,
        });
        this.usingFallback = false;
        this.initialized = true;
        // Remove metadata from the emoji map
        delete data.__meta;
      }

      // Merge with fallback to ensure we have all common emojis
      this.emojiMap = { ...this.getFallbackEmojiMap(), ...data };
      this.initialized = true;

      // Log the sample of loaded emojis
      const emojiCount = Object.keys(this.emojiMap).length;
      const sampleEmojis = Object.entries(this.emojiMap)
        .slice(0, 5)
        .map(([code, emoji]) => `${code}: ${emoji}`);
      this.logInfo(
        `üéâ EmojiContentProcessor: Successfully loaded ${emojiCount} emojis!`
      );
      this.logDebug(
        `üìù EmojiContentProcessor: Sample emojis: ${sampleEmojis.join(", ")}...`
      );

      this.utils.log("Emoji data loaded successfully", {
        mapSize: emojiCount,
      });
    } catch (error) {
      this.logError(
        `‚ùå EmojiContentProcessor: Error loading emoji data:`,
        error
      );
      this.utils.log("Error loading emoji data", { error }, "error");
      this.logWarn(
        "‚ö†Ô∏è EmojiContentProcessor: Using fallback emoji map due to load error"
      );
      // We already have the fallback emoji map from constructor
      this.initialized = true; // Mark as initialised so we can continue
    }
  }

  /**
   * Process emoji shortcodes in content
   * @param {string} content - Content to process
   * @returns {string} Processed content with emoji shortcodes converted to accessible emojis
   */
  process(content) {
    if (!content) return "";

    try {
      // Check if content has potential emoji shortcodes
      if (!content.includes(":")) {
        return content;
      }

      this.utils.log(
        `Processing emoji shortcodes (using ${
          this.usingFallback ? "fallback" : "loaded"
        } emoji map)`
      );
      this.logDebug(
        `üîç EmojiContentProcessor: Processing with ${
          Object.keys(this.emojiMap).length
        } emojis in map`
      );

      // Direct string replacement approach
      return this.replaceEmojiShortcodes(content);
    } catch (error) {
      this.utils.log("Error processing emoji shortcodes", { error }, "error");
      return content;
    }
  }

  /**
   * Replace emoji shortcodes in content with accessible emoji spans
   * @param {string} content - Content to process
   * @returns {string} Processed content with emoji shortcodes converted
   */
  replaceEmojiShortcodes(content) {
    this.logDebug(
      `üîÑ EmojiContentProcessor: Starting to process content for emoji shortcodes`
    );
    this.logDebug(
      `üìã EmojiContentProcessor: Content preview: ${content.substring(
        0,
        100
      )}...`
    );

    // Count total emoji shortcodes before processing
    const totalEmojiCount = (content.match(/:[a-z0-9_+-]+:/g) || []).length;
    this.logDebug(
      `üî¢ EmojiContentProcessor: Found approximately ${totalEmojiCount} potential emoji shortcodes`
    );

    // More permissive regex that works even within HTML tags but not in attributes
    const shortcodeRegex = /(?<!="):([\w+-]+):/g;

    // Check if emojiMap is populated
    this.logDebug(
      `üìä EmojiContentProcessor: Emoji map has ${
        Object.keys(this.emojiMap).length
      } entries`
    );
    this.logDebug(
      `üìù EmojiContentProcessor: First few emojis: ${JSON.stringify(
        Object.entries(this.emojiMap).slice(0, 5)
      )}`
    );

    // Track processed shortcodes for logging
    const processed = new Set();
    const missing = new Set();

    // Log if some common emojis exist in the map
    const testEmojis = ["smile", "heart", "tada", "rocket"];
    testEmojis.forEach((code) => {
      this.logDebug(
        `üîç Testing emoji '${code}': ${
          this.emojiMap[code] ? "Found ‚úÖ" : "Missing ‚ùå"
        }`
      );
    });

    // Replace shortcodes
    const result = content.replace(shortcodeRegex, (match, shortcode) => {
      this.logDebug(`üîé Found shortcode: ${shortcode}`);

      // Check if this shortcode exists in our map
      if (this.emojiMap[shortcode]) {
        const emoji = this.emojiMap[shortcode];
        processed.add(shortcode);

        // Create an accessible span with appropriate ARIA attributes
        return `<span role="img" aria-label="${shortcode}">${emoji}</span>`;
      }

      // Track missing shortcodes
      missing.add(shortcode);

      // If not found, return the original shortcode
      return match;
    });

    // Log what we processed
    if (processed.size > 0) {
      this.logInfo(
        `‚úÖ EmojiContentProcessor: Converted ${
          processed.size
        } emoji shortcodes: ${Array.from(processed).slice(0, 5).join(", ")}${
          processed.size > 5 ? "..." : ""
        }`
      );
      this.utils.log(`Converted ${processed.size} emoji shortcodes`, {
        processedCodes:
          Array.from(processed).slice(0, 5).join(", ") +
          (processed.size > 5 ? "..." : ""),
      });
    } else {
      this.logInfo(
        `‚ÑπÔ∏è EmojiContentProcessor: No emoji shortcodes found or converted`
      );
    }

    // Log any missing shortcodes
    if (missing.size > 0) {
      this.logWarn(
        `‚ö†Ô∏è EmojiContentProcessor: ${
          missing.size
        } emoji shortcodes not found in emoji map: ${Array.from(missing)
          .slice(0, 10)
          .join(", ")}${missing.size > 10 ? "..." : ""}`
      );
      this.utils.log(
        `${missing.size} emoji shortcodes not found in emoji map`,
        {
          missingCodes:
            Array.from(missing).slice(0, 10).join(", ") +
            (missing.size > 10 ? "..." : ""),
        }
      );
    }

    return result;
  }

  /**
   * Get fallback emoji map with essential emojis
   * Used if the JSON file fails to load
   * @returns {Object} Map of emoji shortcodes to emoji characters
   */
  getFallbackEmojiMap() {
    this.utils.log("Using fallback emoji map");

    // Include common emojis as a fallback
    // This expanded list covers many common use cases
    return {
      // Smileys & Emotion
      smile: "üòÑ",
      laughing: "üòÜ",
      blush: "üòä",
      smiley: "üòÉ",
      relaxed: "‚ò∫Ô∏è",
      smirk: "üòè",
      heart_eyes: "üòç",
      kissing_heart: "üòò",
      kissing: "üòó",
      confused: "üòï",
      neutral_face: "üòê",
      expressionless: "üòë",
      unamused: "üòí",
      sweat_smile: "üòÖ",
      sweat: "üòì",
      disappointed: "üòû",
      weary: "üò©",
      pensive: "üòî",
      worried: "üòü",
      angry: "üò†",
      rage: "üò°",
      cry: "üò¢",
      sob: "üò≠",
      joy: "üòÇ",
      slightly_smiling_face: "üôÇ",
      upside_down_face: "üôÉ",
      thinking_face: "ü§î",
      frowning: "üò¶",
      triumph: "üò§",
      sunglasses: "üòé",
      sleeping: "üò¥",
      yum: "üòã",

      // Gestures & People
      thumbsup: "üëç",
      "+1": "üëç",
      thumbsdown: "üëé",
      "-1": "üëé",
      ok_hand: "üëå",
      punch: "üëä",
      fist: "‚úä",
      v: "‚úåÔ∏è",
      wave: "üëã",
      hand: "‚úã",
      raised_hand: "‚úã",
      pray: "üôè",
      clap: "üëè",
      muscle: "üí™",
      metal: "ü§ò",
      person_shrugging: "ü§∑",
      person_facepalming: "ü§¶",

      // Love & Hearts
      heart: "‚ù§Ô∏è",
      yellow_heart: "üíõ",
      green_heart: "üíö",
      blue_heart: "üíô",
      purple_heart: "üíú",
      broken_heart: "üíî",
      two_hearts: "üíï",
      revolving_hearts: "üíû",
      sparkling_heart: "üíñ",

      // Animals
      dog: "üê∂",
      cat: "üê±",
      mouse: "üê≠",
      hamster: "üêπ",
      rabbit: "üê∞",
      fox_face: "ü¶ä",
      bear: "üêª",
      panda_face: "üêº",
      koala: "üê®",
      tiger: "üêØ",
      lion: "ü¶Å",
      cow: "üêÆ",
      pig: "üê∑",
      frog: "üê∏",
      monkey_face: "üêµ",
      monkey: "üêí",
      chicken: "üêî",
      penguin: "üêß",
      bird: "üê¶",
      baby_chick: "üê§",
      elephant: "üêò",
      snake: "üêç",
      dragon: "üêâ",
      unicorn: "ü¶Ñ",

      // Food & Drink
      apple: "üçé",
      green_apple: "üçè",
      pear: "üçê",
      tangerine: "üçä",
      lemon: "üçã",
      banana: "üçå",
      watermelon: "üçâ",
      grapes: "üçá",
      strawberry: "üçì",
      peach: "üçë",
      cherries: "üçí",
      tomato: "üçÖ",
      eggplant: "üçÜ",
      avocado: "ü•ë",
      hamburger: "üçî",
      pizza: "üçï",
      hotdog: "üå≠",
      taco: "üåÆ",
      sushi: "üç£",
      ice_cream: "üç¶",
      cake: "üç∞",
      cookie: "üç™",
      chocolate_bar: "üç´",
      candy: "üç¨",
      lollipop: "üç≠",
      coffee: "‚òï",
      tea: "üçµ",
      beer: "üç∫",
      wine_glass: "üç∑",
      cocktail: "üç∏",

      // Travel & Places
      rocket: "üöÄ",
      airplane: "‚úàÔ∏è",
      helicopter: "üöÅ",
      car: "üöó",
      red_car: "üöó",
      blue_car: "üöô",
      bus: "üöå",
      truck: "üöö",
      boat: "‚õµ",
      sailboat: "‚õµ",
      motorcycle: "üèçÔ∏è",
      bicycle: "üö≤",
      train: "üöÜ",
      station: "üöâ",
      house: "üè†",
      office: "üè¢",
      hospital: "üè•",
      bank: "üè¶",
      school: "üè´",
      hotel: "üè®",
      church: "‚õ™",
      tent: "‚õ∫",
      stadium: "üèüÔ∏è",
      tokyo_tower: "üóº",
      statue_of_liberty: "üóΩ",
      mountain: "‚õ∞Ô∏è",
      sunrise_over_mountains: "üåÑ",
      desert: "üèúÔ∏è",
      beach_with_umbrella: "üèñÔ∏è",
      rainbow: "üåà",
      city_sunset: "üåÜ",

      // Activities
      soccer: "‚öΩ",
      basketball: "üèÄ",
      football: "üèà",
      baseball: "‚öæ",
      tennis: "üéæ",
      bowling: "üé≥",
      golf: "‚õ≥",
      skiing: "üéø",
      snowboarder: "üèÇ",
      swimmer: "üèä",
      surfer: "üèÑ",
      fishing_pole_and_fish: "üé£",
      running: "üèÉ",
      dancer: "üíÉ",
      microphone: "üé§",
      headphones: "üéß",
      musical_note: "üéµ",
      guitar: "üé∏",
      violin: "üéª",
      trumpet: "üé∫",
      saxophone: "üé∑",
      video_game: "üéÆ",
      alien: "üëΩ",
      space_invader: "üëæ",
      robot: "ü§ñ",

      // Objects
      watch: "‚åö",
      iphone: "üì±",
      calling: "üì≤",
      computer: "üíª",
      keyboard: "‚å®Ô∏è",
      desktop: "üñ•Ô∏è",
      printer: "üñ®Ô∏è",
      mouse_three_button: "üñ±Ô∏è",
      trackball: "üñ≤Ô∏è",
      joystick: "üïπÔ∏è",
      camera: "üì∑",
      video_camera: "üìπ",
      movie_camera: "üé•",
      tv: "üì∫",
      radio: "üìª",
      satellite: "üì°",
      bulb: "üí°",
      flashlight: "üî¶",
      candle: "üïØÔ∏è",
      wastebasket: "üóëÔ∏è",
      lock: "üîí",
      key: "üîë",
      hammer: "üî®",
      gun: "üî´",
      bomb: "üí£",
      hocho: "üî™",
      pill: "üíä",
      syringe: "üíâ",
      book: "üìñ",
      books: "üìö",
      newspaper: "üì∞",
      art: "üé®",
      briefcase: "üíº",
      moneybag: "üí∞",
      dollar: "üíµ",
      credit_card: "üí≥",
      gem: "üíé",
      wrench: "üîß",
      hammer_and_wrench: "üõ†Ô∏è",

      // Symbols
      white_check_mark: "‚úÖ",
      heavy_check_mark: "‚úîÔ∏è",
      x: "‚ùå",
      negative_squared_cross_mark: "‚ùé",
      heavy_plus_sign: "‚ûï",
      heavy_minus_sign: "‚ûñ",
      heavy_multiplication_x: "‚úñÔ∏è",
      heavy_division_sign: "‚ûó",
      infinity: "‚ôæÔ∏è",
      bangbang: "‚ÄºÔ∏è",
      interrobang: "‚ÅâÔ∏è",
      question: "‚ùì",
      exclamation: "‚ùó",
      100: "üíØ",
      warning: "‚ö†Ô∏è",
      fire: "üî•",
      star: "‚≠ê",
      sparkles: "‚ú®",
      dizzy: "üí´",
      boom: "üí•",
      star2: "üåü",
      zap: "‚ö°",
      snowflake: "‚ùÑÔ∏è",
      rainbow: "üåà",
      sunny: "‚òÄÔ∏è",
      cloud: "‚òÅÔ∏è",
      umbrella: "‚òÇÔ∏è",
      eyes: "üëÄ",
      ear: "üëÇ",
      nose: "üëÉ",
      lips: "üëÑ",
      tongue: "üëÖ",
      mouth: "üëÑ",
      speech_balloon: "üí¨",
      thought_balloon: "üí≠",
      zzz: "üí§",
      musical_score: "üéº",
    };
  }
}
