/**
 * Chart Builder
 * Generates Chart.js visualizations with full accessibility support
 *
 * Integrates:
 * - ChartDataManager for data processing
 * - ChartTemplateManager for templates
 * - Chart accessibility features (descriptions, tables, export)
 * - Chart controls (themes, view options)
 *
 * @version 1.0.0
 */

const ChartBuilder = (function () {
  "use strict";

  // Logging configuration (inside module scope)
  const LOG_LEVELS = {
    ERROR: 0,
    WARN: 1,
    INFO: 2,
    DEBUG: 3,
  };

  const DEFAULT_LOG_LEVEL = LOG_LEVELS.WARN;
  const ENABLE_ALL_LOGGING = false;
  const DISABLE_ALL_LOGGING = false;

  // Current logging level
  let currentLogLevel = DEFAULT_LOG_LEVEL;

  /**
   * Check if logging should occur based on current level
   * @param {number} level - Log level to check
   * @returns {boolean} Whether logging should occur
   */
  function shouldLog(level) {
    if (DISABLE_ALL_LOGGING) return false;
    if (ENABLE_ALL_LOGGING) return true;
    return level <= currentLogLevel;
  }

  /**
   * Log error messages
   * @param {string} message - Error message
   * @param {...any} args - Additional arguments
   */
  function logError(message, ...args) {
    if (shouldLog(LOG_LEVELS.ERROR)) {
      console.error(`[Chart Builder Error] ${message}`, ...args);
    }
  }

  /**
   * Log warning messages
   * @param {string} message - Warning message
   * @param {...any} args - Additional arguments
   */
  function logWarn(message, ...args) {
    if (shouldLog(LOG_LEVELS.WARN)) {
      console.warn(`[Chart Builder Warning] ${message}`, ...args);
    }
  }

  /**
   * Log informational messages
   * @param {string} message - Info message
   * @param {...any} args - Additional arguments
   */
  function logInfo(message, ...args) {
    if (shouldLog(LOG_LEVELS.INFO)) {
      console.log(`[Chart Builder Info] ${message}`, ...args);
    }
  }

  /**
   * Log debug messages
   * @param {string} message - Debug message
   * @param {...any} args - Additional arguments
   */
  function logDebug(message, ...args) {
    if (shouldLog(LOG_LEVELS.DEBUG)) {
      console.log(`[Chart Builder Debug] ${message}`, ...args);
    }
  }

  /**
   * Set the current logging level
   * @param {number} level - New logging level
   */
  function setLogLevel(level) {
    if (level >= LOG_LEVELS.ERROR && level <= LOG_LEVELS.DEBUG) {
      currentLogLevel = level;
      logInfo(`Logging level set to: ${Object.keys(LOG_LEVELS)[level]}`);
    } else {
      logWarn(
        `Invalid logging level: ${level}. Must be between ${LOG_LEVELS.ERROR} and ${LOG_LEVELS.DEBUG}`
      );
    }
  }

  /**
   * Get the current logging level
   * @returns {number} Current logging level
   */
  function getLogLevel() {
    return currentLogLevel;
  }

  // Configuration
  const CONFIG = {
    containerId: "chart-container",
    defaultWidth: 600,
    defaultHeight: 400,
    enableAccessibility: true,
    enableControls: true,
    autoGenerateDescription: true,
    defaultTheme: null, // Will be determined based on current site theme
  };

  /**
   * Chart initialization status tracking
   */
  const chartRegistry = new Map();

  /**
   * Validates dependencies are available
   * @throws {Error} If required dependencies are missing
   */
  function validateDependencies() {
    logDebug("Validating dependencies...");

    const dependencies = [
      { name: "Chart.js", check: () => typeof Chart !== "undefined" },
      {
        name: "ChartDataManager",
        check: () => typeof ChartDataManager !== "undefined",
      },
      {
        name: "ChartControls",
        check: () => typeof ChartControls !== "undefined",
      },
      {
        name: "ChartAccessibility",
        check: () => typeof ChartAccessibility !== "undefined",
      },
    ];

    const missing = dependencies.filter((dep) => !dep.check());

    if (missing.length > 0) {
      const missingNames = missing.map((dep) => dep.name).join(", ");
      logError(`Missing required dependencies: ${missingNames}`);
      throw new Error(`Missing required dependencies: ${missingNames}`);
    }

    logDebug("All dependencies validated successfully");
  }

  /**
   * Create a chart container element
   * @param {string} chartId - Unique chart ID
   * @param {Object} options - Container options
   * @returns {HTMLElement} Chart container element
   */
  function createChartContainer(chartId, options = {}) {
    logDebug(`Creating chart container for ID: ${chartId}`, options);

    const {
      width = CONFIG.defaultWidth,
      height = CONFIG.defaultHeight,
      appendTo = null,
      className = "",
    } = options;

    // Create container
    const container = document.createElement("div");
    container.id = `chart-container-${chartId}`;
    container.className = `chart-container ${className}`.trim();
    container.setAttribute("aria-label", "Chart");
    container.setAttribute("role", "figure");

    // Set dimensions
    container.style.width = typeof width === "number" ? `${width}px` : width;
    container.style.height =
      typeof height === "number" ? `${height}px` : height;

    // Create canvas
    const canvas = document.createElement("canvas");
    canvas.id = `chart-canvas-${chartId}`;
    canvas.width = typeof width === "number" ? width : 600; // Default if width is a string
    canvas.height = typeof height === "number" ? height : 400; // Default if height is a string

    // Add canvas to container
    container.appendChild(canvas);

    // Add container to DOM if appendTo is specified
    if (appendTo) {
      const target =
        typeof appendTo === "string"
          ? document.getElementById(appendTo)
          : appendTo;
      if (target) {
        target.appendChild(container);
        logDebug(`Chart container appended to: ${appendTo}`);
      } else {
        logWarn(`Target element not found, chart container not added to DOM`);
      }
    }

    logInfo(`Chart container created successfully for ID: ${chartId}`);
    return container;
  }

  /**
   * Build a chart with full accessibility features
   * @param {Object} config - Chart configuration
   * @param {Object} options - Build options
   * @returns {Promise<Object>} Built chart info
   */
  async function buildChart(config, options = {}) {
    try {
      logInfo("Starting chart build process...");
      validateDependencies();

      const {
        chartId = generateChartId(),
        container = null,
        containerOptions = {},
        theme = CONFIG.defaultTheme || determineDefaultTheme(),
        enableAccessibility = CONFIG.enableAccessibility,
        enableControls = CONFIG.enableControls,
        autoGenerateDescription = CONFIG.autoGenerateDescription,
        appendTo = null,
      } = options;

      logDebug(`Building chart with ID: ${chartId}`, {
        theme,
        enableAccessibility,
        enableControls,
      });

      // Create container if not provided
      const chartContainer =
        container ||
        createChartContainer(chartId, {
          ...containerOptions,
          appendTo,
        });

      // Store original chart code for controls
      if (enableControls) {
        const chartCode = JSON.stringify(config);
        chartContainer.setAttribute(
          "data-chart-code",
          encodeURIComponent(chartCode)
        );
        logDebug("Chart code stored for controls functionality");
      }

      // Get canvas element
      const canvasElement =
        chartContainer.querySelector("canvas") ||
        chartContainer.querySelector("*");

      // Create the chart
      logDebug("Initialising Chart.js instance...");
      const chartInstance = new Chart(canvasElement, config);

      // Register the chart for later reference
      chartRegistry.set(chartId, {
        instance: chartInstance,
        container: chartContainer,
        config: config,
      });
      logInfo(`Chart registered with ID: ${chartId}`);

      // Add controls if enabled and available
      if (enableControls && typeof ChartControls !== "undefined") {
        logDebug("Adding chart controls...");
        ChartControls.addControlsToContainer(chartContainer, chartId);

        // Apply theme if specified
        if (theme) {
          ChartControls.applyPalette(chartContainer, canvasElement, theme);
          logDebug(`Applied theme: ${theme}`);
        }
      }

      // Add accessibility features if enabled and available
      if (enableAccessibility && typeof ChartAccessibility !== "undefined") {
        logDebug("Initialising accessibility features...");
        // Wait for chart to be fully rendered
        await new Promise((resolve) => setTimeout(resolve, 100));

        ChartAccessibility.initAccessibilityFeatures(chartContainer, chartId);
        logInfo("Accessibility features initialised successfully");
      }

      logInfo(`Chart built successfully with ID: ${chartId}`);

      // Return chart info
      return {
        chartId,
        instance: chartInstance,
        container: chartContainer,
        element: canvasElement,
      };
    } catch (error) {
      logError("Error building chart:", error);
      throw error;
    }
  }

  /**
   * Create chart from data model
   * @param {string} modelId - Data model ID from ChartDataManager
   * @param {Object} options - Chart options
   * @returns {Promise<Object>} Built chart info
   */
  async function createChartFromModel(modelId, options = {}) {
    try {
      logInfo(`Creating chart from model: ${modelId}`);
      validateDependencies();

      // Get chart configuration from data manager
      logDebug("Retrieving chart configuration from data manager...");
      const chartConfig = ChartDataManager.getChartConfig(
        modelId,
        options.chartOptions || {}
      );

      // Build the chart
      return await buildChart(chartConfig, options);
    } catch (error) {
      logError("Error creating chart from model:", error);
      throw error;
    }
  }

  /**
   * Create chart from template and data
   * @param {string} templateId - Template ID from ChartTemplateManager
   * @param {Object|string} data - Raw data (CSV, JSON, Array)
   * @param {Object} options - Options for chart creation
   * @returns {Promise<Object>} Built chart info
   */
  async function createChartFromTemplate(templateId, data, options = {}) {
    try {
      logInfo(`Creating chart from template: ${templateId}`);
      validateDependencies();

      // Ensure template manager is available
      if (typeof ChartTemplateManager === "undefined") {
        const errorMsg =
          "ChartTemplateManager is required for template-based charts";
        logError(errorMsg);
        throw new Error(errorMsg);
      }

      // Get template
      logDebug("Retrieving template...");
      const template = ChartTemplateManager.getTemplate(templateId);
      if (!template) {
        const errorMsg = `Template not found: ${templateId}`;
        logError(errorMsg);
        throw new Error(errorMsg);
      }

      // Create data model with chart type from template
      logDebug("Creating data model from template...");
      const { model, modelId } = await ChartDataManager.createChartData(
        data,
        template.chartType,
        options.dataOptions || {}
      );

      // Apply template to get configuration
      logDebug("Applying template configuration...");
      const templateConfig = ChartTemplateManager.applyTemplate(
        templateId,
        model.transformedData
      );

      // Merge template configuration with any custom options
      const mergedConfig = mergeConfigurations(
        templateConfig,
        options.chartOptions || {},
        model.transformedData
      );

      // Build the chart
      return await buildChart(mergedConfig, options);
    } catch (error) {
      logError("Error creating chart from template:", error);
      throw error;
    }
  }

  /**
   * Create chart directly from data
   * @param {Object|string} data - Raw data (CSV, JSON, Array)
   * @param {string} chartType - Chart type (bar, line, etc.)
   * @param {Object} options - Options for chart creation
   * @returns {Promise<Object>} Built chart info
   */
  async function createChartFromData(data, chartType, options = {}) {
    try {
      logInfo(`Creating chart from data with type: ${chartType}`);
      validateDependencies();

      // Create data model
      logDebug("Creating data model...");
      const { model, modelId } = await ChartDataManager.createChartData(
        data,
        chartType,
        options.dataOptions || {}
      );

      // Get chart configuration
      logDebug("Retrieving chart configuration...");
      const chartConfig = ChartDataManager.getChartConfig(
        modelId,
        options.chartOptions || {}
      );

      // Build the chart
      return await buildChart(chartConfig, options);
    } catch (error) {
      logError("Error creating chart from data:", error);
      throw error;
    }
  }

  /**
   * Update existing chart with new data
   * @param {string} chartId - Chart ID
   * @param {Object|string} newData - New data (CSV, JSON, Array)
   * @param {Object} options - Update options
   * @returns {Promise<Object>} Updated chart info
   */
  async function updateChartData(chartId, newData, options = {}) {
    try {
      logInfo(`Updating chart data for ID: ${chartId}`);

      // Check if chart exists
      const chartInfo = chartRegistry.get(chartId);
      if (!chartInfo) {
        const errorMsg = `Chart not found: ${chartId}`;
        logError(errorMsg);
        throw new Error(errorMsg);
      }

      // Get chart instance and config
      const { instance, container, config } = chartInfo;

      // Extract model ID from chart config if available
      const modelId = config._modelId; // Assuming we stored model ID in config

      if (modelId) {
        logDebug("Updating existing model...");
        // Update existing model
        await ChartDataManager.updateChartData(
          modelId,
          newData,
          options.dataOptions || {}
        );

        // Get updated configuration
        const updatedConfig = ChartDataManager.getChartConfig(
          modelId,
          options.chartOptions || {}
        );

        // Update chart
        instance.data = updatedConfig.data;
        instance.options = updatedConfig.options;
        instance.update();
        logInfo("Chart data updated successfully");

        // Update data attribute for controls
        if (container) {
          const chartCode = JSON.stringify(updatedConfig);
          container.setAttribute(
            "data-chart-code",
            encodeURIComponent(chartCode)
          );
          logDebug("Chart controls data updated");
        }

        // Update accessibility features if enabled
        if (
          CONFIG.enableAccessibility &&
          typeof ChartAccessibility !== "undefined"
        ) {
          logDebug("Updating accessibility features...");
          ChartAccessibility.initAccessibilityFeatures(container, chartId);
        }

        return {
          chartId,
          instance,
          container,
          element: instance.canvas,
        };
      } else {
        logDebug("No model ID found, recreating chart...");
        // If no model ID, recreate chart
        instance.destroy();

        // Create new chart with same options
        return await createChartFromData(newData, config.type, {
          ...options,
          chartId,
        });
      }
    } catch (error) {
      logError("Error updating chart data:", error);
      throw error;
    }
  }

  /**
   * Destroy chart and clean up resources
   * @param {string} chartId - Chart ID
   * @returns {boolean} Success status
   */
  function destroyChart(chartId) {
    try {
      logInfo(`Destroying chart with ID: ${chartId}`);

      // Check if chart exists
      const chartInfo = chartRegistry.get(chartId);
      if (!chartInfo) {
        logWarn(`Chart not found for destruction: ${chartId}`);
        return false;
      }

      // Get chart instance and container
      const { instance, container } = chartInfo;

      // Destroy chart instance
      logDebug("Destroying chart instance...");
      instance.destroy();

      // Remove container from DOM if it exists
      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
        logDebug("Chart container removed from DOM");
      }

      // Remove from registry
      chartRegistry.delete(chartId);
      logInfo(`Chart destroyed successfully: ${chartId}`);

      return true;
    } catch (error) {
      logError("Error destroying chart:", error);
      return false;
    }
  }

  /**
   * Export chart as image
   * @param {string} chartId - Chart ID
   * @param {Object} options - Export options
   * @returns {Promise<string>} Data URL of exported image
   */
  async function exportChartAsImage(chartId, options = {}) {
    try {
      logInfo(`Exporting chart as image: ${chartId}`);

      // Check if chart exists
      const chartInfo = chartRegistry.get(chartId);
      if (!chartInfo) {
        const errorMsg = `Chart not found: ${chartId}`;
        logError(errorMsg);
        throw new Error(errorMsg);
      }

      // Get chart instance
      const { instance } = chartInfo;

      // Export as image
      logDebug("Converting chart to base64 image...");
      const dataUrl = instance.toBase64Image();

      // If download option is set, trigger download
      if (options.download) {
        logDebug("Triggering image download...");
        const downloadLink = document.createElement("a");
        downloadLink.href = dataUrl;
        downloadLink.download = options.filename || `chart-${chartId}.png`;
        downloadLink.click();
        logInfo("Chart image download triggered");
      }

      return dataUrl;
    } catch (error) {
      logError("Error exporting chart as image:", error);
      throw error;
    }
  }

  /**
   * Get all charts
   * @returns {Array} Array of chart info objects
   */
  function getAllCharts() {
    logDebug(`Retrieving all charts. Count: ${chartRegistry.size}`);
    return Array.from(chartRegistry.entries()).map(([id, info]) => ({
      chartId: id,
      ...info,
    }));
  }

  /**
   * Get chart by ID
   * @param {string} chartId - Chart ID
   * @returns {Object|null} Chart info or null if not found
   */
  function getChart(chartId) {
    logDebug(`Retrieving chart: ${chartId}`);
    const chartInfo = chartRegistry.get(chartId);
    return chartInfo ? { chartId, ...chartInfo } : null;
  }

  /**
   * Generate unique chart ID
   * @returns {string} Unique ID
   */
  function generateChartId() {
    const id =
      "chart-" + Date.now() + "-" + Math.random().toString(36).substring(2, 9);
    logDebug(`Generated chart ID: ${id}`);
    return id;
  }

  /**
   * Determine default theme based on site settings
   * @returns {string} Theme name
   */
  function determineDefaultTheme() {
    logDebug("Determining default theme...");

    // Use ChartControls utility if available
    if (typeof ChartControls !== "undefined" && ChartControls.utils) {
      const theme = ChartControls.utils.getDefaultPaletteForCurrentMode();
      logDebug(`Theme determined via ChartControls: ${theme}`);
      return theme;
    }

    // Fallback: check for dark mode using media query
    if (
      window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches
    ) {
      logDebug("Dark mode detected, using Paul Tol Bright theme");
      return "Paul Tol Bright"; // Default dark theme
    } else {
      logDebug("Light mode detected, using Okabe and Ito theme");
      return "Okabe and Ito"; // Default light theme
    }
  }

  /**
   * Merge multiple configurations
   * @param {Object} baseConfig - Base configuration
   * @param {Object} customConfig - Custom configuration
   * @param {Object} chartData - Chart data
   * @returns {Object} Merged configuration
   */
  function mergeConfigurations(baseConfig, customConfig, chartData) {
    logDebug("Merging chart configurations...");

    // Create deep copy of base config
    const result = JSON.parse(JSON.stringify(baseConfig));

    // Ensure data is properly set
    if (chartData) {
      result.data = chartData;
      logDebug("Chart data merged into configuration");
    }

    // Deep merge custom config
    deepMerge(result, customConfig);
    logDebug("Custom configuration merged successfully");

    return result;
  }

  /**
   * Deep merge objects
   * @param {Object} target - Target object
   * @param {Object} source - Source object
   * @returns {Object} Merged object
   */
  function deepMerge(target, source) {
    if (!source) return target;

    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (
          source[key] &&
          typeof source[key] === "object" &&
          !Array.isArray(source[key])
        ) {
          // Create key if it doesn't exist
          if (!target[key]) {
            target[key] = {};
          }

          // Recursive merge for objects
          deepMerge(target[key], source[key]);
        } else {
          // Direct assignment for primitives and arrays
          target[key] = source[key];
        }
      }
    }

    return target;
  }

  /**
   * Get data extraction API for chart
   * @param {string} chartId - Chart ID
   * @returns {Object|null} Data extraction API or null if chart not found
   */
  function getChartDataAPI(chartId) {
    logDebug(`Creating data API for chart: ${chartId}`);
    const chartInfo = chartRegistry.get(chartId);
    if (!chartInfo) {
      logWarn(`Chart not found for data API: ${chartId}`);
      return null;
    }

    const { instance } = chartInfo;

    return {
      getLabels: () => instance.data.labels,
      getDatasets: () => instance.data.datasets,
      getRawData: () => instance.data,
      getDataAtIndex: (datasetIndex, index) => {
        const dataset = instance.data.datasets[datasetIndex];
        return dataset ? dataset.data[index] : null;
      },
      getValueAtLabel: (datasetIndex, label) => {
        const labelIndex = instance.data.labels.indexOf(label);
        if (labelIndex === -1) return null;

        const dataset = instance.data.datasets[datasetIndex];
        return dataset ? dataset.data[labelIndex] : null;
      },
    };
  }

  // Module initialisation
  logInfo("ChartBuilder module initialised successfully");

  // Public API
  return {
    // Chart creation
    buildChart,
    createChartFromModel,
    createChartFromTemplate,
    createChartFromData,

    // Chart management
    updateChartData,
    destroyChart,
    getAllCharts,
    getChart,

    // Export functionality
    exportChartAsImage,

    // Data access
    getChartDataAPI,

    // Configuration
    setDefaultTheme: (theme) => {
      CONFIG.defaultTheme = theme;
      logInfo(`Default theme set to: ${theme}`);
    },
    setDefaultDimensions: (width, height) => {
      CONFIG.defaultWidth = width;
      CONFIG.defaultHeight = height;
      logInfo(`Default dimensions set to: ${width}x${height}`);
    },
    setAccessibilityEnabled: (enabled) => {
      CONFIG.enableAccessibility = enabled;
      logInfo(`Accessibility ${enabled ? "enabled" : "disabled"}`);
    },
    setControlsEnabled: (enabled) => {
      CONFIG.enableControls = enabled;
      logInfo(`Controls ${enabled ? "enabled" : "disabled"}`);
    },

    // Logging controls
    setLogLevel,
    getLogLevel,
    LOG_LEVELS: { ...LOG_LEVELS }, // Read-only copy

    // Utility functions
    generateChartId,

    // Config access (read-only)
    getConfig: () => ({ ...CONFIG }),
  };
})();

// Export for use in other modules
if (typeof module !== "undefined" && module.exports) {
  module.exports = ChartBuilder;
} else {
  window.ChartBuilder = ChartBuilder;
}
