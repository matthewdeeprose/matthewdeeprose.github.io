// template-system.js
// Enhanced Template Engine Module - Pure Vanilla JavaScript
// Replaces string concatenation with maintainable templates
// WCAG 2.2 AA compliant with British spelling

const TemplateSystem = (function () {
  "use strict";

  // ===========================================================================================
  // LOGGING CONFIGURATION
  // ===========================================================================================

  const LOG_LEVELS = { ERROR: 0, WARN: 1, INFO: 2, DEBUG: 3 };
  const DEFAULT_LOG_LEVEL = LOG_LEVELS.INFO;
  const ENABLE_ALL_LOGGING = false;
  const DISABLE_ALL_LOGGING = false;

  function shouldLog(level) {
    if (DISABLE_ALL_LOGGING) return false;
    if (ENABLE_ALL_LOGGING) return true;
    return level <= DEFAULT_LOG_LEVEL;
  }

  function logError(message, ...args) {
    if (shouldLog(LOG_LEVELS.ERROR))
      console.error("[TemplateSystem]", message, ...args);
  }

  function logWarn(message, ...args) {
    if (shouldLog(LOG_LEVELS.WARN))
      console.warn("[TemplateSystem]", message, ...args);
  }

  function logInfo(message, ...args) {
    if (shouldLog(LOG_LEVELS.INFO))
      console.log("[TemplateSystem]", message, ...args);
  }

  function logDebug(message, ...args) {
    if (shouldLog(LOG_LEVELS.DEBUG))
      console.log("[TemplateSystem]", message, ...args);
  }

  // ===========================================================================================
  // PERFORMANCE MONITORING
  // ===========================================================================================

  const performanceMetrics = {
    renderCount: 0,
    totalRenderTime: 0,
    cacheHits: 0,
    cacheMisses: 0,
  };

  function measurePerformance(fn, name) {
    return function (...args) {
      const start = window.performance.now();
      try {
        return fn.apply(this, args);
      } finally {
        const duration = window.performance.now() - start;
        performanceMetrics.totalRenderTime += duration;
        performanceMetrics.renderCount++;
        if (duration > 10) {
          logWarn(
            `[TemplateSystem] Slow template render for "${name}": ${duration.toFixed(
              2
            )}ms`
          );
        }
      }
    };
  }

  // ===========================================================================================
  // GLOBAL TEMPLATE CACHE SINGLETON
  // ===========================================================================================

  // Global singleton cache to prevent duplicate template loading
  const GlobalTemplateCache = {
    templates: new Map(),
    loadingPromise: null,
    isLoaded: false, // ‚ö†Ô∏è DEPRECATED - use state instead
    loadAttempted: false, // ‚ö†Ô∏è DEPRECATED - use state instead
    state: "uninitialized", // ‚úÖ NEW: 'uninitialized' | 'loading' | 'loaded' | 'failed'

    /**
     * Ensure external templates are loaded with singleton pattern and state machine.
     *
     * Uses centralized state machine to prevent duplicate template loading across
     * multiple engine instances. States: 'uninitialized' | 'loading' | 'loaded' | 'failed'.
     * Returns immediately if already loaded, waits if currently loading, retries if
     * previous load failed. Critical for Phase 2 race condition elimination.
     *
     * The state machine ensures that:
     * - Multiple simultaneous initialization attempts share the same loading promise
     * - Failed loads can be retried by subsequent calls
     * - Template data is loaded exactly once and cached globally
     * - All engine instances wait for the same loading operation
     *
     * @returns {Promise<Object>} Loading results with loaded and failed template arrays
     * @returns {Array<string>} Object.loaded - Successfully loaded template names
     * @returns {Array<Object>} Object.failed - Failed templates with error details
     * @throws {Error} If template loading encounters critical error during fetch operations
     *
     * @example
     * const results = await GlobalTemplateCache.ensureTemplatesLoaded();
     * console.log(`Loaded ${results.loaded.length} templates`);
     * // Returns: { loaded: ['template1', 'template2'], failed: [] }
     */
    async ensureTemplatesLoaded() {
      // If already loaded, return immediately
      if (this.state === "loaded" || this.isLoaded) {
        logDebug("‚úÖ Templates already loaded from global cache");
        return { loaded: Array.from(this.templates.keys()), failed: [] };
      }

      // If currently loading, wait for existing promise
      if (this.loadingPromise) {
        logDebug("‚è≥ Waiting for existing template loading operation...");
        try {
          const results = await this.loadingPromise;
          return results;
        } catch (error) {
          logWarn(
            "[TemplateSystem] Error waiting for existing promise:",
            error.message
          );
          this.loadingPromise = null;
          this.state = "failed";
          this.isLoaded = false; // Keep old flag in sync
          return { loaded: [], failed: [] };
        }
      }

      // If previous load failed, allow retry
      if (this.state === "failed") {
        logInfo("üîÑ Retrying template load after previous failure...");
        this.state = "uninitialized";
        this.isLoaded = false;
        this.loadAttempted = false;
      }

      // Mark as loading (both systems)
      this.state = "loading";
      this.loadAttempted = true;
      this.loadingPromise = this.loadExternalTemplates();

      try {
        const results = await this.loadingPromise;

        // Update both state systems
        if (results.loaded.length > 0) {
          this.state = "loaded";
          this.isLoaded = true;
          logInfo(`‚úÖ Global cache loaded: ${results.loaded.length} templates`);
        } else {
          this.state = "uninitialized";
          this.isLoaded = false;
          logDebug("‚ö†Ô∏è No templates loaded yet");
        }

        this.loadingPromise = null;
        return results;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå Global template loading failed:",
          error.message
        );
        this.state = "failed";
        this.isLoaded = false;
        this.loadingPromise = null;
        return { loaded: [], failed: [] };
      }
    },

    /**
     * Load external template files from templates directory with error handling.
     *
     * Fetches template HTML files from the templates/ directory, processes each file
     * through mapExternalFilenameToTemplateName() for naming, and stores successfully
     * loaded templates in the global cache Map. Failed templates are logged with
     * detailed error information but do not prevent other templates from loading.
     *
     * Templates are loaded from these locations:
     * - templates/*.html - Main template files
     * - templates/partials/*.html - Reusable template components
     *
     * @returns {Promise<Object>} Loading results object with loaded and failed arrays
     * @returns {Array<string>} Object.loaded - Array of successfully loaded template names
     * @returns {Array<Object>} Object.failed - Array of failure objects with {file, error} properties
     * @throws {Error} Does not throw - errors are captured in failed array for graceful degradation
     *
     * @example
     * const results = await GlobalTemplateCache.loadExternalTemplates();
     * console.log(`Loaded: ${results.loaded.length}, Failed: ${results.failed.length}`);
     * // Returns: { loaded: ['template1', 'partial-header'], failed: [{file: 'broken.html', error: '404'}] }
     */
    async loadExternalTemplates() {
      logInfo("üöÄ GLOBAL: Loading external templates (singleton)...");

      // List of external template files to load
      const externalTemplateFiles = [
        "reading-tools-section.html",
        "theme-toggle-section.html",
        "print-button-section.html",
        "reset-controls-section.html",
        "mathjax-accessibility-controls.html",
        "integrated-document-sidebar.html",
        "table-of-contents.html",
        "embedded-fonts.html",
        "partials/font-option.html",
        "partials/width-option.html",
        "partials/zoom-option.html",
        "prism-css.html",
        "prism-js.html",
        "credits-acknowledgements.html",
      ];

      const results = { loaded: [], failed: [] };

      for (const fileName of externalTemplateFiles) {
        try {
          const response = await fetch(`templates/${fileName}`);
          if (!response.ok)
            throw new Error(`[TemplateSystem] HTTP ${response.status}`);

          const content = await response.text();
          const templateName = this.mapExternalFilenameToTemplateName(fileName);

          this.templates.set(templateName, content);
          results.loaded.push(templateName);
          logDebug(`‚úÖ GLOBAL: Loaded ${templateName} from ${fileName}`);
        } catch (error) {
          results.failed.push({ file: fileName, error: error.message });
          logWarn(
            `[TemplateSystem] ‚ö†Ô∏è GLOBAL: Failed to load ${fileName}:`,
            error.message
          );
        }
      }

      logInfo(
        `‚úÖ GLOBAL: Template loading complete: ${results.loaded.length}/${externalTemplateFiles.length} loaded`
      );
      return results;
    },

    /**
     * Map external template filename to internal template name for cache storage.
     *
     * Converts filesystem paths to template identifiers using a predefined mapping
     * dictionary. This allows templates to be referenced by clean camelCase names
     * like 'readingToolsSection' rather than kebab-case filenames. The mapping
     * supports hierarchical organization with partials/ subdirectory.
     *
     * Transformation examples:
     * - 'reading-tools-section.html' ‚Üí 'readingToolsSection'
     * - 'partials/font-option.html' ‚Üí 'fontOption'
     * - 'embedded-fonts.html' ‚Üí 'embedded-fonts'
     *
     * @param {string} fileName - Template filename from templates/ directory
     * @returns {string} Clean template name for cache key and template references
     *
     * @example
     * const name = mapExternalFilenameToTemplateName('partials/font-option.html');
     * console.log(name); // 'fontOption'
     */
    mapExternalFilenameToTemplateName(fileName) {
      const mappings = {
        "reading-tools-section.html": "readingToolsSection",
        "theme-toggle-section.html": "themeToggleSection",
        "print-button-section.html": "printButtonSection",
        "reset-controls-section.html": "resetControlsSection",
        "mathjax-accessibility-controls.html": "mathJaxAccessibilityControls",
        "integrated-document-sidebar.html": "integratedDocumentSidebar",
        "table-of-contents.html": "tableOfContents",
        "embedded-fonts.html": "embedded-fonts",
        "partials/font-option.html": "fontOption",
        "partials/width-option.html": "widthOption",
        "partials/zoom-option.html": "zoomOption",
        "prism-css.html": "prismCSS",
        "prism-js.html": "prismJS",
        "credits-acknowledgements.html": "creditsAcknowledgements",
      };
      return mappings[fileName] || fileName.replace(/\.html$/, "");
    },

    /**
     * Retrieve a template from the global cache by name.
     *
     * Simple accessor for the global template Map. Returns the raw template HTML
     * string if found, or undefined if the template name does not exist in cache.
     * No error is thrown for missing templates to allow graceful fallback handling.
     *
     * @param {string} templateName - Template name (camelCase, e.g., 'readingToolsSection')
     * @returns {string|undefined} Template HTML content if found, undefined if not in cache
     *
     * @example
     * const html = GlobalTemplateCache.getTemplate('readingToolsSection');
     * if (html) {
     *   // Use template
     * } else {
     *   // Handle missing template
     * }
     */
    getTemplate(templateName) {
      return this.templates.get(templateName);
    },

    /**
     * Check if a template exists in the global cache without retrieving it.
     *
     * Efficient existence check using Map.has() that returns boolean result.
     * Useful for conditional logic and validation before attempting to render
     * templates. Does not trigger any loading or fallback mechanisms.
     *
     * @param {string} templateName - Template name to check
     * @returns {boolean} True if template exists in cache, false otherwise
     *
     * @example
     * if (GlobalTemplateCache.hasTemplate('custom-header')) {
     *   // Render custom version
     * } else {
     *   // Use default header
     * }
     */
    hasTemplate(templateName) {
      return this.templates.has(templateName);
    },

    /**
     * Get a copy of all templates in the global cache for inspection or copying.
     *
     * Returns a shallow copy of the templates Map to prevent external modification
     * of the global cache. The template HTML strings themselves are not cloned,
     * but the Map structure is copied. Useful for debugging, reporting, and
     * creating new engine instances with the current template set.
     *
     * @returns {Map<string, string>} New Map containing all cached template name-HTML pairs
     *
     * @example
     * const allTemplates = GlobalTemplateCache.getAllTemplates();
     * console.log(`Cache contains ${allTemplates.size} templates`);
     * allTemplates.forEach((html, name) => console.log(`- ${name}`));
     */
    getAllTemplates() {
      return new Map(this.templates);
    },

    /**
     * Clear the global template cache and reset state machine for fresh loading.
     *
     * Removes all cached templates from memory and resets all initialization state
     * flags to allow templates to be reloaded. This includes both the new state
     * machine (state = 'uninitialized') and deprecated flags (isLoaded, loadAttempted)
     * for backward compatibility. The loadingPromise is also cleared to prevent
     * waiting for stale operations.
     *
     * Primary use cases:
     * - Testing and development (reload templates without page refresh)
     * - Memory management (free resources when templates no longer needed)
     * - Error recovery (clear corrupted cache state)
     *
     * @returns {void}
     *
     * @example
     * GlobalTemplateCache.clearCache();
     * // Cache is now empty, next ensureTemplatesLoaded() will reload from files
     */
    clearCache() {
      logWarn("[TemplateSystem] üßπ Clearing global template cache...");
      this.templates.clear();
      this.loadingPromise = null;
      // Reset both old and new state systems
      this.state = "uninitialized";
      this.isLoaded = false;
      this.loadAttempted = false;
    },
  };

  // ===========================================================================================
  // LIGHTWEIGHT TEMPLATE ENGINE WITH GLOBAL CACHING
  // ===========================================================================================

  class EnhancedTemplateEngine {
    constructor() {
      this.templates = new Map();
      this.compiledTemplates = new Map(); // Cache for compiled templates
      this.partials = new Map();
      this.helpers = new Map();
      this.filters = new Map();
      this.isInitializing = false; // Prevent duplicate initialization
      this._initializationPromise = null; // Track async initialization

      this.setupDefaultHelpers();
      this.setupDefaultFilters();

      // ‚úÖ FIX: Always initialize from global cache with inline fallback
      this._initializationPromise = this.initializeFromGlobalCacheAsync();

      logDebug(
        "[TemplateSystem] Template engine constructed - templates loading"
      );
    }

    // ===========================================================================================
    // TEMPLATE INITIALIZATION & STATE MANAGEMENT
    // ===========================================================================================
    // Functions controlling template loading, initialization pathways, and state management.
    // CRITICAL: This section is being refactored to fix race conditions - see Phase 2.

    /**
     * ‚ö° FIXED: Proper template initialization with immediate fallback
     */
    initializeTemplatesSync() {
      // Prevent duplicate initialization
      if (this.isInitializing) {
        logDebug("Template initialization already in progress, skipping");
        return;
      }

      this.isInitializing = true;

      // ‚úÖ CRITICAL FIX: Always ensure we have templates before proceeding
      if (
        GlobalTemplateCache.isLoaded &&
        GlobalTemplateCache.templates.size > 0
      ) {
        logDebug("üöÄ Using existing global cache for template initialization");
        // Synchronously copy from already-loaded global cache
        this.copyFromGlobalCache();
        this.isInitializing = false;
      } else {
        logDebug(
          "üìã External templates not available - using inline fallbacks"
        );
        // ‚úÖ NEW: Initialize with inline templates immediately to prevent test failures
        this.initializeInlineTemplates();
        this.isInitializing = false;

        // Schedule async upgrade to external templates
        this.scheduleGlobalCacheUpgrade();
      }
    }

    /**
     * üéØ NEW: Force template loading with blocking wait
     */
    initializeWithMandatoryWait() {
      // Start async loading but make it blocking for this instance
      GlobalTemplateCache.ensureTemplatesLoaded()
        .then(() => {
          if (
            GlobalTemplateCache.isLoaded &&
            GlobalTemplateCache.templates.size > 0
          ) {
            this.copyFromGlobalCache();
            logInfo(
              `‚úÖ Template engine loaded ${this.templates.size} templates after mandatory wait`
            );
          } else {
            logWarn(
              "[TemplateSystem] ‚ö†Ô∏è Global cache still empty after loading attempt"
            );
          }
          this.isInitializing = false;
        })
        .catch((error) => {
          logError(
            "[TemplateSystem] ‚ùå Mandatory template loading failed:",
            error.message
          );
          this.isInitializing = false;
        });
    }

    /**
     * üéØ PHASE 5.6: Synchronous wrapper for async template initialization
     */
    initializeExternalTemplatesOnlySync() {
      // Start async loading and handle completion
      this.initializeExternalTemplatesOnly()
        .then(() => {
          logDebug("‚úÖ Async template initialization completed successfully");
          this.isInitializing = false;
        })
        .catch((error) => {
          logError(
            "[TemplateSystem] ‚ùå Failed to initialize external templates:",
            error.message
          );
          this.isInitializing = false;
          // Don't throw here to prevent breaking the sync initialization
        });
    }

    /**
     * üéØ PHASE 5.6: Initialize external templates only - SYNCHRONOUS loading to fix race condition
     */
    async initializeExternalTemplatesOnly() {
      try {
        logInfo(
          "Initialising external templates only - no fallbacks available"
        );

        // ‚úÖ PHASE 5.6 FIX: Wait for external templates to load synchronously
        logDebug(
          "‚è≥ Loading external templates synchronously to avoid race condition..."
        );
        const results = await GlobalTemplateCache.ensureTemplatesLoaded();

        if (results.loaded.length > 0) {
          // Copy templates from global cache immediately
          this.copyFromGlobalCache();
          logInfo(
            `‚úÖ Successfully loaded ${results.loaded.length} external templates synchronously`
          );
          logDebug(
            "Template system initialized with external-only mode and templates loaded"
          );
        } else {
          logWarn(
            "[TemplateSystem] ‚ö†Ô∏è No external templates loaded - template rendering may fail"
          );
          logError(
            "[TemplateSystem] üí° Please ensure templates/ directory is accessible and contains required files"
          );
        }

        // Validate template loading success
        if (this.templates.size === 0) {
          throw new Error(
            "[TemplateSystem] Failed to load any external templates - template system unusable"
          );
        } else {
          logDebug(
            `‚úÖ Template engine ready with ${this.templates.size} templates loaded`
          );
        }
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå External template initialization failed:",
          error.message
        );
        logError(
          "[TemplateSystem] üí° Please ensure templates/ directory is accessible and contains required files"
        );
        throw new Error(
          "[TemplateSystem] Template system initialization failed - external templates required"
        );
      }
    }

    /**
     * ‚úÖ NEW: Async initialization that ensures global cache is loaded
     * Returns a promise that resolves when templates are ready
     */
    async initializeFromGlobalCacheAsync() {
      try {
        // If global cache already loaded, use it immediately
        if (
          GlobalTemplateCache.state === "loaded" &&
          GlobalTemplateCache.templates.size > 0
        ) {
          logDebug("[TemplateSystem] Using pre-loaded global cache");
          this.copyFromGlobalCache();
          return;
        }

        // Load inline templates as immediate fallback
        logDebug("[TemplateSystem] Loading inline fallback templates");
        this.initializeInlineTemplates();

        // Then try to upgrade to external templates
        try {
          const results = await GlobalTemplateCache.ensureTemplatesLoaded();
          if (results.loaded.length > 0) {
            logInfo(
              `[TemplateSystem] Upgraded to ${results.loaded.length} external templates`
            );
            this.copyFromGlobalCache();
          } else {
            logWarn(
              "[TemplateSystem] External templates not available, using inline fallbacks"
            );
          }
        } catch (error) {
          logWarn(
            "[TemplateSystem] Failed to load external templates, using inline fallbacks:",
            error.message
          );
        }
      } catch (error) {
        logError("[TemplateSystem] Template initialization failed:", error);
        // Ensure we have at least inline templates
        if (this.templates.size === 0) {
          this.initializeInlineTemplates();
        }
      }
    }

    /**
     * Initialize inline fallback templates when external loading fails.
     *
     * ‚ö†Ô∏è DEVELOPMENT ALERT: This fallback system should ideally never be used in
     * production. It provides minimal emergency templates to prevent complete
     * rendering failure when external template files cannot be loaded. The inline
     * templates are intentionally basic to encourage fixing the external loading
     * rather than relying on fallbacks.
     *
     * Fallback templates provided:
     * - readingToolsSection: Basic font and size controls
     * - themeToggleSection: Light/dark theme switcher
     * - mathJaxAccessibilityControls: MathJax zoom and navigation
     * - printButtonSection: Simple print button
     * - resetControlsSection: Settings reset button
     * - integratedDocumentSidebar: Navigation sidebar structure
     * - tableOfContents: Basic TOC generation
     * - embedded-fonts: Font embedding CSS template
     * - Partials: fontOption, widthOption, zoomOption
     *
     * These templates lack the full feature set of external templates and should
     * only serve as emergency stopgaps during development or when deployment
     * configuration prevents external file loading.
     *
     * @returns {void}
     *
     * @example
     * // Only called when external loading fails
     * if (!this.templates.size) {
     *   this.initializeInlineTemplates();
     *   logWarn('Using fallback templates - fix external loading!');
     * }
     */
    /**
     * Copy templates from global singleton cache to this engine instance.
     *
     * Synchronously copies all templates from the GlobalTemplateCache to this
     * engine instance's local templates Map. This operation only succeeds if
     * the global cache has been loaded and contains templates. If the global
     * cache is not ready, templates remain unchanged (no warning in this version
     * as it's expected during async initialization).
     *
     * This method is called during initialization to ensure each engine instance
     * has its own copy of the template data, preventing cross-instance interference
     * while still benefiting from centralized loading via the singleton.
     *
     * PHASE 5.6: External templates only - no inline template preservation.
     * The compiled template cache is cleared to ensure fresh rendering with
     * the newly loaded templates.
     *
     * @returns {void}
     *
     * @example
     * const engine = new EnhancedTemplateEngine();
     * await GlobalTemplateCache.ensureTemplatesLoaded();
     * engine.copyFromGlobalCache();
     * console.log(`Engine has ${engine.templates.size} templates`);
     */
    copyFromGlobalCache() {
      const globalTemplates = GlobalTemplateCache.getAllTemplates();
      if (globalTemplates.size > 0) {
        // ‚úÖ PHASE 5.5: No inline template preservation - all templates from external files
        globalTemplates.forEach((content, templateName) => {
          this.templates.set(templateName, content);
          logDebug(`üìã Loaded external template: ${templateName}`);
        });
        // ‚ö° FIX: Use debug level to reduce duplicate messages
        logDebug(
          `‚úÖ Template engine loaded ${globalTemplates.size} external templates from global cache`
        );
        this.compiledTemplates.clear(); // Clear cache for fresh templates
      }
    }

    /**
     * Initialize inline fallback templates when external loading fails.
     *
     * ‚ö†Ô∏è DEVELOPMENT ALERT: This fallback system should ideally never be used in
     * production. It provides minimal emergency templates to prevent complete
     * rendering failure when external template files cannot be loaded. The inline
     * templates are intentionally basic to encourage fixing the external loading
     * rather than relying on fallbacks.
     *
     * Fallback templates provided:
     * - readingToolsSection: Basic font and size controls
     * - themeToggleSection: Light/dark theme switcher
     * - mathJaxAccessibilityControls: MathJax zoom and navigation
     * - printButtonSection: Simple print button
     * - resetControlsSection: Settings reset button
     * - integratedDocumentSidebar: Navigation sidebar structure
     * - tableOfContents: Basic TOC generation
     * - embedded-fonts: Font embedding CSS template
     * - Partials: fontOption, widthOption, zoomOption
     *
     * These templates lack the full feature set of external templates and should
     * only serve as emergency stopgaps during development or when deployment
     * configuration prevents external file loading.
     *
     * @returns {void}
     *
     * @example
     * // Only called when external loading fails
     * if (!this.templates.size) {
     *   this.initializeInlineTemplates();
     *   logWarn('Using fallback templates - fix external loading!');
     * }
     */
    initializeInlineTemplates() {
      console.warn(
        "[TemplateSystem] DEVELOPMENT ALERT: Initialising with inline fallback templates. " +
          "External templates will be loaded asynchronously. " +
          "This is expected on first initialisation but may indicate missing files if persistent."
      );
      logDebug("Initializing with inline template fallbacks");

      // Minimal inline templates for immediate functionality
      this.templates.set(
        "readingToolsSection",
        `
    <div class="reading-tools-section">
      <h3>Reading Tools</h3>
      <div class="font-controls">
        <label for="font-family">Font:</label>
        <select id="font-family">
          {{#each fontOptions}}
          <option value="{{value}}"{{#if selected}} selected{{/if}}>{{label}}</option>
          {{/each}}
        </select>
      </div>
      <div class="font-size-controls">
        <label for="font-size">Font size:</label>
        <input type="range" id="font-size" min="0.5" max="3" step="0.1" value="{{fontSize}}">
      </div>
    </div>
  `
      );

      this.templates.set(
        "themeToggleSection",
        `
    <button class="theme-toggle" onclick="toggleTheme()" aria-label="{{ariaLabel}}">
      <span aria-hidden="true">{{icon}}</span> {{text}}
    </button>
  `
      );

      this.templates.set(
        "mathJaxAccessibilityControls",
        `
    <div class="mathjax-accessibility-controls">
      <h3>MathJax Accessibility</h3>
      <div class="zoom-controls">
        {{#each zoomOptions}}
        <label>
          <input type="radio" name="zoom-trigger" value="{{value}}"{{#if checked}} checked{{/if}}>
          {{label}}
        </label>
        {{/each}}
      </div>
    </div>
  `
      );

      this.templates.set(
        "printButtonSection",
        `
    <button class="print-button" onclick="window.print()">
      <span aria-hidden="true">üñ®Ô∏è</span> Print Document
    </button>
  `
      );

      this.templates.set(
        "resetControlsSection",
        `
    <button class="reset-controls" onclick="resetAccessibilitySettings()">
      Reset Settings
    </button>
  `
      );

      this.templates.set(
        "integratedDocumentSidebar",
        `
    <aside class="document-sidebar">
      <nav aria-label="Document navigation">
        {{> tableOfContents}}
      </nav>
    </aside>
  `
      );

      this.templates.set(
        "tableOfContents",
        `
    <div class="table-of-contents">
      <h3>Contents</h3>
      {{#if sections}}
      <ul>
        {{#each sections}}
        <li><a href="#{{formatId title}}">{{title}}</a></li>
        {{/each}}
      </ul>
      {{else}}
      <p>No sections found</p>
      {{/if}}
    </div>
  `
      );

      this.templates.set(
        "embedded-fonts",
        `
    {{#if base64Regular}}
    <style>
    @font-face {
      font-family: 'OpenDyslexic';
      src: url(data:font/truetype;charset=utf-8;base64,{{base64Regular}}) format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    {{#if base64Bold}}
    @font-face {
      font-family: 'OpenDyslexic';
      src: url(data:font/truetype;charset=utf-8;base64,{{base64Bold}}) format('truetype');
      font-weight: bold;
      font-style: normal;
    }
    {{/if}}
    </style>
    {{/if}}
  `
      );

      // Partials
      this.templates.set(
        "fontOption",
        `
    <option value="{{value}}"{{#if selected}} selected{{/if}}>{{label}}</option>
  `
      );

      this.templates.set(
        "widthOption",
        `
    <option value="{{value}}"{{#if selected}} selected{{/if}}>{{label}}</option>
  `
      );

      this.templates.set(
        "zoomOption",
        `
    <option value="{{value}}"{{#if selected}} selected{{/if}}>{{label}}</option>
  `
      );

      logInfo(
        `‚úÖ Initialized ${this.templates.size} inline template fallbacks`
      );
    }

    /**
     * Schedule asynchronous upgrade of global template cache with state machine coordination.
     *
     * Provides async initialization pathway that coordinates with the
     * global state machine to prevent race conditions. This method checks the current
     * state and either waits for ongoing loading, triggers new loading, or immediately
     * completes if templates are already cached.
     *
     * State machine integration ensures:
     * - No duplicate loading operations across multiple engine instances
     * - Proper waiting when templates are currently being loaded
     * - Graceful retry if previous load attempts failed
     * - Seamless coordination between sync and async initialization paths
     *
     * Upgrade flow:
     * 1. Check if templates already loaded (size >= 10) - skip if complete
     * 2. If global cache state is 'loaded' - copy templates immediately
     * 3. If state is 'uninitialized' or 'failed' - trigger loading and wait
     * 4. Small delay (100ms) prevents race conditions during initialization
     *
     * After templates are loaded, this method copies them to the engine instance
     * via copyFromGlobalCache(). If loading fails, the engine continues with
     * whatever templates it currently has (likely inline fallbacks).
     *
     * @returns {void}
     *
     * @example
     * const engine = new EnhancedTemplateEngine();
     * // Engine initializes with inline fallbacks, then schedules upgrade
     * // Upgrade happens automatically after 100ms
     */
    scheduleGlobalCacheUpgrade() {
      // Only upgrade if not already upgraded
      setTimeout(async () => {
        // Check if upgrade is still needed
        if (this.templates.size >= 10) {
          logDebug("Templates already loaded, skipping upgrade");
          return;
        }

        // Check global cache state (use NEW state machine)
        if (GlobalTemplateCache.state === "loaded") {
          this.copyFromGlobalCache();
          logInfo("Upgraded to external templates from global cache");
          return;
        }

        // If cache not loaded yet, try to load it
        if (
          GlobalTemplateCache.state === "uninitialized" ||
          GlobalTemplateCache.state === "failed"
        ) {
          try {
            logInfo("Initiating global template load for upgrade");
            const results = await GlobalTemplateCache.ensureTemplatesLoaded();
            if (results.loaded.length > 0) {
              this.copyFromGlobalCache();
              logInfo(
                `√¢≈ì‚Ä¶ Upgraded to ${results.loaded.length} external templates`
              );
            }
          } catch (error) {
            logWarn(
              "[TemplateSystem] Failed to upgrade to external templates:",
              error.message
            );
          }
        }
      }, 100); // Small delay to prevent race conditions
    }

    // ===========================================================================================
    // PHASE 4B: TEMPLATE INHERITANCE SYSTEM
    // ===========================================================================================

    /**
     * Parse template inheritance directives from template content.
     *
     * Extracts template inheritance information by parsing {{#extend "parent-name"}}
     * directives and all {{#block "block-name"}} definitions within the template.
     * This is the entry point for template inheritance processing - it identifies
     * which parent template (if any) this template extends and catalogues all
     * block definitions that can override parent blocks.
     *
     * Template inheritance directives:
     * - {{#extend "parent-name"}} - Declares parent template to inherit from
     * - {{#block "block-name"}}content{{/block}} - Defines overridable content block
     *
     * Parsing delegates to parseBlocksWithNesting() for robust block extraction
     * with proper nesting support. This allows blocks to contain other blocks,
     * enabling sophisticated template composition patterns.
     *
     * @param {string} templateContent - Raw template content to parse for directives
     * @returns {Object} Inheritance information object
     * @returns {string|null} Object.parent - Name of parent template or null if no inheritance
     * @returns {Map} Object.blocks - Map of blockName ‚Üí blockContent for all blocks found
     *
     * @example
     * // Template with inheritance:
     * // {{#extend "base"}}{{#block "title"}}Child Title{{/block}}
     * const info = engine.parseInheritance(templateContent);
     * // Returns: { parent: "base", blocks: Map { "title" => "Child Title" } }
     *
     * @example
     * // Template without inheritance:
     * // <h1>{{title}}</h1>
     * const info = engine.parseInheritance(templateContent);
     * // Returns: { parent: null, blocks: Map {} }
     */
    parseInheritance(templateContent) {
      const inheritance = {
        parent: null,
        blocks: new Map(),
      };

      // Parse {{#extend "parent-template"}}
      const extendMatch = templateContent.match(/\{\{#extend\s+"([^"]+)"\}\}/);
      if (extendMatch) {
        inheritance.parent = extendMatch[1];
        logDebug(`[TemplateSystem] Template extends: ${extendMatch[1]}`);
      }

      // NEW: Parse blocks with proper nesting support
      this.parseBlocksWithNesting(templateContent, inheritance.blocks);

      return inheritance;
    }

    /**
     * Parse block definitions with depth-aware nesting support.
     *
     * Extracts all {{#block}} definitions from template content using a depth
     * counter algorithm to correctly match opening and closing tags even when
     * blocks are nested inside other blocks. This is critical for template
     * inheritance to work correctly with complex template structures.
     *
     * Algorithm uses depth tracking:
     * 1. Find each {{#block "name"}} opening tag
     * 2. Track depth counter (starts at 1)
     * 3. Scan forward: increment depth on nested {{#block}}, decrement on {{/block}}
     * 4. When depth reaches 0, we've found the matching closing tag
     * 5. Extract content between matching tags
     *
     * This approach handles arbitrarily nested structures like:
     * {{#block "outer"}}
     *   {{#block "inner"}}content{{/block}}
     * {{/block}}
     *
     * Parsing results are stored directly in the provided blocksMap parameter
     * (mutates the map). Logs warnings for malformed blocks with missing closing tags.
     *
     * @param {string} templateContent - Template content to parse for block directives
     * @param {Map} blocksMap - Map to store found blocks (blockName ‚Üí blockContent)
     * @returns {void} Results stored directly in blocksMap parameter (no return value)
     *
     * @example
     * const blocks = new Map();
     * // Template: {{#block "title"}}My Title{{/block}}
     * parseBlocksWithNesting(template, blocks);
     * console.log(blocks.get('title')); // "My Title"
     *
     * @example
     * // Nested blocks:
     * const blocks = new Map();
     * // {{#block "outer"}}Text {{#block "inner"}}Nested{{/block}}{{/block}}
     * parseBlocksWithNesting(template, blocks);
     * console.log(blocks.get('outer')); // "Text {{#block \"inner\"}}Nested{{/block}}"
     * console.log(blocks.get('inner')); // "Nested"
     */
    parseBlocksWithNesting(templateContent, blocksMap) {
      const blockStartRegex = /\{\{#block\s+"([^"]+)"\}\}/g;
      let match;

      while ((match = blockStartRegex.exec(templateContent)) !== null) {
        const blockName = match[1];
        const startPos = match.index;
        const startTag = match[0];

        // Find the matching end tag by counting depth
        let depth = 1;
        let currentPos = startPos + startTag.length;
        let endPos = -1;

        while (depth > 0 && currentPos < templateContent.length) {
          // Look for next block start or end
          const nextBlockStart = templateContent.indexOf(
            "{{#block",
            currentPos
          );
          const nextBlockEnd = templateContent.indexOf(
            "{{/block}}",
            currentPos
          );

          if (nextBlockEnd === -1) {
            // No closing tag found - invalid template
            logWarn(
              `[TemplateSystem] No closing tag found for block "${blockName}"`
            );
            break;
          }

          // If we find another opening tag before the closing tag, increase depth
          if (nextBlockStart !== -1 && nextBlockStart < nextBlockEnd) {
            depth++;
            currentPos = nextBlockStart + 8; // Move past '{{#block'
          } else {
            // Found a closing tag
            depth--;
            if (depth === 0) {
              // This is our matching closing tag
              endPos = nextBlockEnd;
            }
            currentPos = nextBlockEnd + 10; // Move past '{{/block}}'
          }
        }

        if (endPos !== -1) {
          // Extract the content between the tags
          const blockContent = templateContent.substring(
            startPos + startTag.length,
            endPos
          );
          blocksMap.set(blockName, blockContent);
          logDebug(
            `[TemplateSystem] Found block "${blockName}" with ${blockContent.length} chars`
          );

          // Check if this block contains nested blocks for debugging
          if (blockContent.includes("{{#block")) {
            logDebug(
              `[TemplateSystem] Block "${blockName}" contains nested blocks`
            );
          }
        } else {
          logError(
            `[TemplateSystem] Failed to parse block "${blockName}" - no matching end tag`
          );
        }
      }

      logDebug(`[TemplateSystem] Parsed ${blocksMap.size} blocks total`);
    }

    /**
     * Process template inheritance by walking the inheritance chain and applying block overrides.
     *
     * Main coordinator for template inheritance processing. Walks the complete
     * inheritance chain from child template up to the root base template, collects
     * all block definitions along the way (with child blocks overriding parent blocks),
     * then processes the base template by substituting collected blocks.
     *
     * Processing workflow:
     * 1. Check for circular inheritance (prevents infinite loops)
     * 2. Parse template for {{#extend}} directive - skip if no inheritance
     * 3. Walk inheritance chain using walkInheritanceChain() (child ‚Üí base)
     * 4. Collect all blocks using collectAllBlocks() (child overrides parent)
     * 5. Process base template using processTemplateWithBlocks() (substitute blocks)
     * 6. Fallback to basic cleanup if any step fails
     *
     * Circular dependency prevention uses processedTemplates Set to track which
     * templates have been processed in the current chain. If a template appears
     * twice in the same chain, inheritance is circular and processing stops.
     *
     * Templates without inheritance (no {{#extend}} directive) are cleaned by
     * removing any orphaned block directives and returning their content only.
     *
     * @param {string} templateName - Name of template to process (must exist in templates Map)
     * @param {Set} [processedTemplates=new Set()] - Set of template names already processed (circular detection)
     * @returns {string} Fully processed template content with inheritance resolved
     * @throws {Error} [TemplateSystem] If circular inheritance chain detected
     *
     * @example
     * // base.html: <h1>{{#block "title"}}Default{{/block}}</h1>
     * // child.html: {{#extend "base"}}{{#block "title"}}Child Title{{/block}}
     * const result = engine.processInheritance('child');
     * // Returns: "<h1>Child Title</h1>"
     *
     * @example
     * // Template without inheritance:
     * const result = engine.processInheritance('standalone');
     * // Returns: template content with {{#block}} directives cleaned up
     */
    processInheritance(templateName, processedTemplates = new Set()) {
      // Prevent circular inheritance
      if (processedTemplates.has(templateName)) {
        logWarn(
          `[TemplateSystem] Circular inheritance detected for template: ${templateName}`
        );
        return this.templates.get(templateName) || "";
      }

      const template = this.templates.get(templateName);
      if (!template) {
        logError(
          `[TemplateSystem] Template not found for inheritance: ${templateName}`
        );
        return "";
      }

      const inheritance = this.parseInheritance(template);

      if (!inheritance.parent) {
        // No inheritance - clean up any orphaned block directives
        let result = template;
        result = result.replace(/\{\{#extend\s+"[^"]+"\}\}/g, "");
        result = result.replace(/\{\{\/extend\}\}/g, "");
        // Clean orphaned blocks by keeping their content
        result = result.replace(
          /\{\{#block\s+"[^"]+"\}\}([\s\S]*?)\{\{\/block\}\}/g,
          (match, blockContent) => blockContent.trim()
        );
        return result;
      }

      // NEW APPROACH: Walk entire inheritance chain and collect all blocks
      try {
        // Add current template to processed set to prevent circular deps
        processedTemplates.add(templateName);

        // Walk the chain from child to base
        const chain = this.walkInheritanceChain(
          templateName,
          processedTemplates
        );

        // Collect all blocks with proper precedence
        const allBlocks = this.collectAllBlocks(chain);

        // Get the base template (first in chain)
        const baseTemplate = chain[0];

        logDebug(
          `[TemplateSystem] Processing inheritance chain: ${chain
            .map((t) => t.templateName)
            .join(" ‚Üí ")}`
        );
        logDebug(
          `[TemplateSystem] Collected ${allBlocks.size} unique blocks from chain`
        );

        // Process the base template with all collected blocks
        return this.processTemplateWithBlocks(baseTemplate.content, allBlocks);
      } catch (error) {
        logError(
          `[TemplateSystem] Error processing inheritance chain for ${templateName}:`,
          error
        );
        // Fallback to the original template with cleanup
        let result = template;
        result = result.replace(/\{\{#extend\s+"[^"]+"\}\}/g, "");
        result = result.replace(/\{\{\/extend\}\}/g, "");
        result = result.replace(
          /\{\{#block\s+"[^"]+"\}\}([\s\S]*?)\{\{\/block\}\}/g,
          (match, blockContent) => blockContent.trim()
        );
        return result;
      }
    }

    /**
     * Walk inheritance chain from child template to root base template.
     *
     * Builds the complete inheritance chain by following {{#extend}} directives
     * upward from the child template to the root base template (which has no parent).
     * Returns an ordered array from base ‚Üí child, with each entry containing both
     * the template name and its content for subsequent block collection.
     *
     * Chain building algorithm:
     * 1. Start with current template (child)
     * 2. Parse to find {{#extend "parent-name"}} directive
     * 3. Add current template to beginning of chain (maintains base ‚Üí child order)
     * 4. Move to parent template and repeat
     * 5. Stop when template has no parent (reached base)
     *
     * The base ‚Üí child ordering is critical for correct block precedence in
     * collectAllBlocks() - later templates in the chain override earlier ones.
     *
     * Circular inheritance detection: If a template appears twice in the chain,
     * throws error to prevent infinite loops.
     *
     * @param {string} templateName - Name of starting template (typically child)
     * @param {Set} [processedTemplates=new Set()] - Set for circular dependency prevention (optional)
     * @returns {Array<Object>} Inheritance chain ordered from base to child
     * @returns {string} Array[].templateName - Name of template in chain
     * @returns {string} Array[].content - Raw content of template
     * @throws {Error} [TemplateSystem] If circular inheritance detected in chain
     * @throws {Error} [TemplateSystem] If any template in chain not found
     *
     * @example
     * // grandparent.html (no extend), parent.html extends grandparent, child.html extends parent
     * const chain = engine.walkInheritanceChain('child');
     * // Returns: [
     * //   { templateName: 'grandparent', content: '...' },
     * //   { templateName: 'parent', content: '...' },
     * //   { templateName: 'child', content: '...' }
     * // ]
     */
    walkInheritanceChain(templateName, processedTemplates = new Set()) {
      const chain = [];
      let currentTemplate = templateName;

      // Walk up the chain to collect all templates
      while (currentTemplate) {
        if (chain.some((item) => item.templateName === currentTemplate)) {
          throw new Error(
            `[TemplateSystem] Circular inheritance detected: ${currentTemplate}`
          );
        }

        const content = this.templates.get(currentTemplate);
        if (!content) {
          throw new Error(
            `[TemplateSystem] Template not found: ${currentTemplate}`
          );
        }

        // Add to beginning to maintain base->child order
        chain.unshift({ templateName: currentTemplate, content });

        // Parse to find parent
        const inheritance = this.parseInheritance(content);
        currentTemplate = inheritance.parent;
      }

      logDebug(
        `[TemplateSystem] Built inheritance chain: ${chain
          .map((t) => t.templateName)
          .join(" ‚Üí ")}`
      );
      return chain;
    }

    /**
     * Collect all block definitions from inheritance chain with child-override precedence.
     *
     * Merges block definitions from all templates in the inheritance chain into a
     * single Map, applying proper override semantics where child template blocks
     * replace parent template blocks with the same name. This implements standard
     * template inheritance behaviour found in systems like Jinja2 and Django templates.
     *
     * Block precedence rules:
     * - Base template defines default block content
     * - Each child template can override specific blocks
     * - Later templates in chain override earlier ones for same block name
     * - Final Map contains the "winning" content for each block name
     *
     * Processing order is critical: chain must be ordered base ‚Üí child (as returned
     * by walkInheritanceChain()) so that child blocks correctly override parent blocks
     * when stored in the Map using set() operations.
     *
     * Example precedence:
     * - base.html: {{#block "title"}}Default{{/block}}
     * - child.html: {{#block "title"}}Override{{/block}}
     * - Result: Map { "title" => "Override" }
     *
     * @param {Array<Object>} chain - Inheritance chain from base to child (ordered)
     * @param {string} chain[].templateName - Name of template
     * @param {string} chain[].content - Template content
     * @returns {Map<string, string>} Map of blockName ‚Üí blockContent with overrides applied
     *
     * @example
     * // Chain: [base, child]
     * // base has: {{#block "header"}}Base Header{{/block}}
     * // child has: {{#block "header"}}Child Header{{/block}}
     * const blocks = engine.collectAllBlocks(chain);
     * console.log(blocks.get('header')); // "Child Header" (child wins)
     *
     * @example
     * // Multiple blocks with partial overrides:
     * // base: {{#block "title"}}Title{{/block}}{{#block "body"}}Body{{/block}}
     * // child: {{#block "title"}}New Title{{/block}}
     * const blocks = engine.collectAllBlocks(chain);
     * console.log(blocks.get('title')); // "New Title" (overridden)
     * console.log(blocks.get('body'));  // "Body" (inherited from base)
     */
    collectAllBlocks(chain) {
      const allBlocks = new Map();

      // Process from base to child - later templates override earlier ones
      chain.forEach(({ templateName, content }) => {
        const inheritance = this.parseInheritance(content);
        inheritance.blocks.forEach((blockContent, blockName) => {
          allBlocks.set(blockName, blockContent);
          logDebug(
            `[TemplateSystem] Block "${blockName}" defined/overridden by ${templateName}`
          );
        });
      });

      return allBlocks;
    }

    /**
     * Process base template by substituting all block directives with collected block content.
     *
     * Final stage of template inheritance processing. Takes the root base template
     * and replaces all {{#block "name"}} directives with the corresponding content
     * from the allBlocks Map (which contains merged blocks from entire inheritance chain).
     * Uses multi-pass iterative processing to handle nested block structures correctly.
     *
     * Multi-pass processing algorithm:
     * 1. Iterate through all blocks in the Map
     * 2. Replace {{#block "name"}}...{{/block}} with block content
     * 3. Check if any replacements were made (hasChanges flag)
     * 4. If changes made, repeat (handles newly-exposed nested blocks)
     * 5. Stop when no more changes or max iterations reached (prevents infinite loops)
     * 6. Clean up any orphaned block directives (keep content, remove tags)
     *
     * Iteration limit (10) prevents infinite loops in case of malformed templates
     * or circular block references. Logs warning if limit reached.
     *
     * After processing, verifies no {{#block}}, {{/block}}, {{#extend}}, or {{/extend}}
     * directives remain in the output. Remaining directives indicate potential
     * template syntax errors and trigger warnings.
     *
     * @param {string} baseTemplate - Root base template content with {{#block}} directives
     * @param {Map<string, string>} allBlocks - Map of blockName ‚Üí blockContent from inheritance chain
     * @returns {string} Fully processed template with all blocks substituted and directives removed
     *
     * @example
     * // baseTemplate: "<h1>{{#block \"title\"}}Default{{/block}}</h1>"
     * // allBlocks: Map { "title" => "Custom Title" }
     * const result = engine.processTemplateWithBlocks(baseTemplate, allBlocks);
     * // Returns: "<h1>Custom Title</h1>"
     *
     * @example
     * // Nested blocks (multi-pass):
     * // baseTemplate: "{{#block \"outer\"}}{{#block \"inner\"}}Text{{/block}}{{/block}}"
     * // allBlocks: Map { "outer" => "A", "inner" => "B" }
     * const result = engine.processTemplateWithBlocks(baseTemplate, allBlocks);
     * // Pass 1: Replaces "outer" ‚Üí "A"
     * // Pass 2: No more blocks to replace
     * // Returns: "A"
     */
    processTemplateWithBlocks(baseTemplate, allBlocks) {
      let result = baseTemplate;

      // Remove extend directives first (shouldn't be in base, but be safe)
      result = result.replace(/\{\{#extend\s+"[^"]+"\}\}/g, "");
      result = result.replace(/\{\{\/extend\}\}/g, "");

      // Multi-pass processing to handle nested blocks
      let hasChanges = true;
      let iterations = 0;
      const maxIterations = 10;

      while (hasChanges && iterations < maxIterations) {
        hasChanges = false;
        iterations++;

        logDebug(`[TemplateSystem] Block processing iteration ${iterations}`);

        // Process blocks one at a time to handle nested structures
        for (const [blockName, blockContent] of allBlocks) {
          const blockRegex = new RegExp(
            `\\{\\{#block\\s+"${blockName}"\\}\\}[\\s\\S]*?\\{\\{\\/block\\}\\}`,
            "g"
          );

          const beforeReplace = result;

          // Replace all occurrences of this block
          result = result.replace(blockRegex, blockContent.trim());

          if (result !== beforeReplace) {
            hasChanges = true;
            logDebug(
              `[TemplateSystem] Iteration ${iterations}: Applied block "${blockName}"`
            );
          }
        }

        // If no specific block replacements, clean orphaned blocks
        if (!hasChanges) {
          const beforeCleanup = result;
          result = result.replace(
            /\{\{#block\s+"[^"]+"\}\}([\s\S]*?)\{\{\/block\}\}/g,
            (match, blockContent) => {
              logDebug(`[TemplateSystem] Cleaning orphaned block directive`);
              return blockContent.trim();
            }
          );

          if (result !== beforeCleanup) {
            hasChanges = true;
          }
        }
      }

      if (iterations >= maxIterations) {
        logWarn("[TemplateSystem] Max iterations reached in block processing");
      }

      // Final verification
      const hasRemainingDirectives =
        result.includes("{{#block") ||
        result.includes("{{/block}}") ||
        result.includes("{{#extend") ||
        result.includes("{{/extend}}");

      if (hasRemainingDirectives) {
        logWarn(
          "[TemplateSystem] Some template directives remain after processing"
        );
        logDebug("Remaining content sample:", result.substring(0, 300));
      } else {
        logDebug(
          "[TemplateSystem] Template inheritance processing complete - all directives resolved"
        );
      }

      return result;
    }

    /**
     * Find all blocks in a template with their content
     * @param {string} template - Template to analyze
     * @returns {Array} Array of {name, content, startPos, endPos}
     */
    findAllBlocks(template) {
      const blocks = [];
      const regex = /\{\{#block\s+"([^"]+)"\}\}/g;
      let match;

      while ((match = regex.exec(template)) !== null) {
        const blockName = match[1];
        const startPos = match.index;
        const startTag = match[0];

        // Find matching end tag
        let depth = 1;
        let currentPos = startPos + startTag.length;
        let endPos = -1;

        while (depth > 0 && currentPos < template.length) {
          const nextOpen = template.indexOf("{{#block", currentPos);
          const nextClose = template.indexOf("{{/block}}", currentPos);

          if (nextClose === -1) break;

          if (nextOpen !== -1 && nextOpen < nextClose) {
            depth++;
            currentPos = nextOpen + 8;
          } else {
            depth--;
            currentPos = nextClose + 10;
            if (depth === 0) {
              endPos = nextClose + 10;
            }
          }
        }

        if (endPos !== -1) {
          const fullBlock = template.substring(startPos, endPos);
          const content = template.substring(
            startPos + startTag.length,
            endPos - 10
          );
          blocks.push({
            name: blockName,
            content: content,
            fullBlock: fullBlock,
            startPos: startPos,
            endPos: endPos,
          });
        }
      }

      return blocks;
    }

    /**
     * Analyze block dependencies (which blocks contain other blocks)
     * @param {string} template - Template content
     * @param {Map} allBlocks - All available blocks
     * @returns {Object} Dependency information
     */
    analyzeBlockDependencies(template, allBlocks) {
      const dependencies = {};

      // Check each block's content for nested blocks
      allBlocks.forEach((content, blockName) => {
        const nestedBlocks = this.findAllBlocks(content);
        if (nestedBlocks.length > 0) {
          dependencies[blockName] = nestedBlocks.map((b) => b.name);
        } else {
          dependencies[blockName] = [];
        }
      });

      return dependencies;
    }

    /**
     * Find all block positions in template with depth information
     * @param {string} template - Template content
     * @returns {Array} Array of block information with position and depth
     */
    findBlockPositions(template) {
      const blocks = [];
      const regex = /\{\{#block\s+"([^"]+)"\}\}/g;
      let match;

      while ((match = regex.exec(template)) !== null) {
        const blockName = match[1];
        const startPos = match.index;
        const endTag = `{{/block}}`;

        // Find the corresponding end tag
        let depth = 1;
        let currentPos = startPos + match[0].length;
        let endPos = -1;

        while (depth > 0 && currentPos < template.length) {
          // Look for next block start or end
          const nextBlockStart = template.indexOf("{{#block", currentPos);
          const nextBlockEnd = template.indexOf(endTag, currentPos);

          if (nextBlockEnd === -1) {
            // No closing tag found
            break;
          }

          if (nextBlockStart !== -1 && nextBlockStart < nextBlockEnd) {
            // Found a nested block start
            depth++;
            currentPos = nextBlockStart + 8; // Skip past {{#block
          } else {
            // Found a block end
            depth--;
            if (depth === 0) {
              endPos = nextBlockEnd + endTag.length;
            }
            currentPos = nextBlockEnd + endTag.length;
          }
        }

        if (endPos !== -1) {
          blocks.push({
            name: blockName,
            startPos: startPos,
            endPos: endPos,
            fullMatch: template.substring(startPos, endPos),
            depth: this.calculateBlockDepth(template, startPos),
          });
        }
      }

      return blocks;
    }

    /**
     * Calculate the nesting depth of a block
     * @param {string} template - Template content
     * @param {number} position - Position of the block
     * @returns {number} Nesting depth (0 = top level)
     */
    calculateBlockDepth(template, position) {
      let depth = 0;
      const beforeBlock = template.substring(0, position);

      // Count unclosed block starts before this position
      const blockStarts = (beforeBlock.match(/\{\{#block\s+"[^"]+"\}\}/g) || [])
        .length;
      const blockEnds = (beforeBlock.match(/\{\{\/block\}\}/g) || []).length;

      depth = blockStarts - blockEnds;
      return Math.max(0, depth);
    }

    /**
     * Sort blocks by depth (deepest first)
     * @param {Array} blocks - Array of block information
     * @returns {Array} Sorted array
     */
    sortBlocksByDepth(blocks) {
      return blocks.sort((a, b) => b.depth - a.depth);
    }

    /**
     * Replace a specific block at its exact position
     * @param {string} template - Template content
     * @param {Object} blockInfo - Block position information
     * @param {string} replacement - Replacement content
     * @returns {string} Updated template
     */
    replaceBlockAtPosition(template, blockInfo, replacement) {
      return (
        template.substring(0, blockInfo.startPos) +
        replacement +
        template.substring(blockInfo.endPos)
      );
    }

    /**
     * Initialize templates from global cache (non-blocking)
     */
    async initializeFromGlobalCache() {
      try {
        const results = await GlobalTemplateCache.ensureTemplatesLoaded();

        // Copy external templates from global cache to instance
        const globalTemplates = GlobalTemplateCache.getAllTemplates();
        globalTemplates.forEach((content, templateName) => {
          this.templates.set(templateName, content);
          logDebug(`üìã Copied ${templateName} from global cache`);
        });

        logInfo(
          `‚úÖ Template engine loaded ${globalTemplates.size} external templates from global cache`
        );

        // Clear compiled cache to ensure fresh templates
        this.compiledTemplates.clear();

        return results;
      } catch (error) {
        logWarn(
          "[TemplateSystem] Failed to load from global cache, using inline templates:",
          error.message
        );
        return { loaded: [], failed: [] };
      }
    }

    // ===========================================================================================
    // TEMPLATE COMPILATION & RENDERING
    // ===========================================================================================
    // Core template rendering with variable substitution, conditionals, loops, and partials.
    // Includes caching for performance optimization.

    /**
     * Main render method with caching, automatic default data, and async initialization wait.
     * PHASE 4B: Enhanced with template inheritance support via processInheritance()
     *
     * Primary entry point for all template rendering. Automatically merges default template
     * data with user-provided data, processes template inheritance, and returns compiled HTML.
     * If templates are not yet loaded, this method returns a Promise that waits for
     * initialization to complete before rendering.
     *
     * Features:
     * - Automatic default data merging (getDefaultTemplateData)
     * - Template inheritance processing ({{#extend}} and {{#block}} directives)
     * - Compiled template caching for performance
     * - Graceful async initialization waiting when templates not ready
     *
     * @param {string} templateName - Name of template to render (e.g., 'readingToolsSection')
     * @param {Object} [userData={}] - User data to merge with template defaults
     * @returns {string|Promise<string>} Rendered HTML string, or Promise if waiting for initialization
     * @throws {Error} Does not throw - returns HTML comment with error message on failure
     *
     * @example
     * // Synchronous rendering (templates already loaded)
     * const html = engine.render('themeToggleSection', { isDarkMode: true });
     *
     * @example
     * // Async rendering (templates still loading)
     * const html = await engine.render('readingToolsSection');
     */
    render(templateName, userData = {}) {
      // ‚úÖ FIX: Check if template exists, if not wait for initialization
      if (!this.templates.has(templateName) && this._initializationPromise) {
        logWarn(
          `[TemplateSystem] Template "${templateName}" not yet loaded, waiting for initialization...`
        );
        // Return a promise that waits for initialization then renders
        return this._initializationPromise
          .then(() => {
            return this._renderInternal(templateName, userData);
          })
          .catch((error) => {
            logError(
              `[TemplateSystem] Initialization failed, cannot render:`,
              error
            );
            return `<!-- Template "${templateName}" not available: ${error.message} -->`;
          });
      }

      return this._renderInternal(templateName, userData);
    }

    /**
     * Internal synchronous render method with inheritance processing and caching.
     *
     * Called by render() after ensuring templates are loaded. Handles the complete
     * rendering workflow: data merging, inheritance processing, compilation, and
     * caching. This method always executes synchronously and returns a string.
     *
     * Rendering workflow:
     * 1. Merge default template data with user data
     * 2. Process template inheritance ({{#extend}} and {{#block}} directives)
     * 3. Check compiled template cache (cache key includes inheritance processing)
     * 4. Compile template if not cached (via compileTemplate)
     * 5. Execute compiled template function with merged data
     * 6. Return rendered HTML string
     *
     * Performance optimization: Compiled templates are cached with inheritance
     * already processed, so inheritance resolution only happens once per template.
     *
     * @param {string} templateName - Name of template to render
     * @param {Object} [userData={}] - User data to merge with defaults
     * @returns {string} Rendered HTML string
     * @throws {Error} Does not throw - returns HTML comment on error
     *
     * @example
     * const html = engine._renderInternal('tableOfContents', { sections: [...] });
     * // Returns: "<div class="table-of-contents">...</div>"
     */
    _renderInternal(templateName, userData = {}) {
      // Automatically merge default data
      const defaultData = this.getDefaultTemplateData(templateName);
      const data = { ...defaultData, ...userData };

      logDebug(`Rendering "${templateName}" with merged data:`, data);

      // PHASE 4B: Process inheritance first
      const processedTemplate = this.processInheritance(templateName);
      if (!processedTemplate) {
        logError(`[TemplateSystem] Template "${templateName}" not found`);
        return `<!-- Template "${templateName}" not found -->`;
      }

      try {
        // Create cache key that includes inheritance processing
        const cacheKey = `${templateName}_inheritance`;

        // Check cache first
        let compiledTemplate = this.compiledTemplates.get(cacheKey);
        if (!compiledTemplate) {
          performanceMetrics.cacheMisses++;
          logDebug(
            `Cache MISS for template: ${templateName} (misses: ${performanceMetrics.cacheMisses})`
          );
          // Compile the processed template (with inheritance resolved)
          compiledTemplate = this.compileTemplate(processedTemplate);
          this.compiledTemplates.set(cacheKey, compiledTemplate);
          logDebug(
            `Compiled and cached template with inheritance: ${templateName}`
          );
        } else {
          performanceMetrics.cacheHits++;
          logDebug(
            `Cache HIT for template: ${templateName} (hits: ${performanceMetrics.cacheHits})`
          );
        }

        return compiledTemplate(data);
      } catch (error) {
        logError(
          `[TemplateSystem] Error rendering template "${templateName}":`,
          error
        );
        return `<!-- Error rendering template "${templateName}": ${error.message} -->`;
      }
    }

    /**
     * Render a partial template with data inheritance from parent context.
     *
     * Partials are reusable template fragments referenced with {{> partialName}} syntax.
     * This method handles the three-layer data merging: default data ‚Üí parent context ‚Üí
     * specific partial data. This allows partials to access both their own defaults and
     * variables from the parent template (like loop items).
     *
     * Data merging order (later overrides earlier):
     * 1. Partial's default data (from getDefaultTemplateData)
     * 2. Parent template's data context
     * 3. Specific data passed to partial
     *
     * If the partial template is not found, returns empty string with warning
     * (graceful degradation prevents breaking parent template rendering).
     *
     * @param {string} partialName - Name of partial template to render
     * @param {Object} data - Specific data for this partial invocation
     * @param {Object} parentData - Data context from parent template
     * @returns {string} Rendered partial HTML, or empty string if not found
     *
     * @example
     * // In template: {{> fontOption value="Arial" label="Arial Font"}}
     * // Parent has: { selectedFont: "Arial" }
     * const html = engine.renderPartial('fontOption',
     *   { value: "Arial", label: "Arial Font" },
     *   { selectedFont: "Arial" }
     * );
     */
    renderPartial(partialName, data, parentData) {
      const template = this.templates.get(partialName);
      if (!template) {
        logWarn(`[TemplateSystem] Partial "${partialName}" not found`);
        return "";
      }

      // Get default data for this partial
      const defaultData = this.getDefaultTemplateData(partialName);

      // Merge in this order: defaults -> parent data -> specific data
      const mergedData = { ...defaultData, ...parentData, ...data };

      logDebug(
        `Rendering partial "${partialName}" with merged data:`,
        mergedData
      );

      // ‚úÖ FIX: Use compileTemplate and direct processing instead of recursive renderTemplate
      try {
        const compiledTemplate = this.compileTemplate(template);
        return compiledTemplate(mergedData);
      } catch (error) {
        logError(
          `[TemplateSystem] Error rendering partial "${partialName}":`,
          error
        );
        return `<!-- Error rendering partial "${partialName}": ${error.message} -->`;
      }
    }

    /**
     * Compile template string to executable function for performance optimization.
     *
     * Converts template syntax into a reusable function that processes directives
     * in the correct order to handle nested structures properly. The compilation
     * is wrapped with measurePerformance for monitoring slow renders (>10ms).
     *
     * Template directive processing order (critical for correctness):
     * 1. {{#each}} loops - Process first so partials have access to item context
     * 2. {{> partial}} - Render partials with current loop context
     * 3. {{#if}}/{{else}} - Conditional rendering with else support
     * 4. {{#block}} - Template inheritance block extraction
     * 5. {{{raw}}} - Unescaped HTML output
     * 6. {{variable}} - Variable substitution with HTML escaping and filters
     *
     * The compiled function is cached in compiledTemplates Map for reuse.
     * Each invocation processes the template recursively to handle nested
     * directives (loops containing conditionals, partials with variables, etc.).
     *
     * @param {string} template - Raw template string with directive syntax
     * @returns {Function} Compiled template function that accepts data object
     *
     * @example
     * const compiled = engine.compileTemplate('Hello {{name}}!');
     * const html = compiled({ name: 'World' });
     * console.log(html); // "Hello World!"
     */
    compileTemplate(template) {
      const self = this; // Capture 'this' for use in nested function

      const processTemplate = measurePerformance(function (tpl, data) {
        let result = tpl;

        // Process {{#each}} loops with @index, @first, @last support
        // CRITICAL: Process loops BEFORE partials so partials have access to item context
        result = result.replace(
          /\{\{#each\s+([^}]+)\}\}([\s\S]*?)\{\{\/each\}\}/g,
          (match, arrayPath, content) => {
            const array = self.getNestedValue(data, arrayPath.trim());
            if (!Array.isArray(array)) return "";

            return array
              .map((item, index) => {
                const itemContext =
                  typeof item === "object"
                    ? {
                        ...data,
                        ...item,
                        "@index": index,
                        "@first": index === 0,
                        "@last": index === array.length - 1,
                      }
                    : {
                        ...data,
                        this: item,
                        "@index": index,
                        "@first": index === 0,
                        "@last": index === array.length - 1,
                      };
                return processTemplate(content, itemContext);
              })
              .join("");
          }
        );

        // Process partials {{> partialName}}
        // Now partials can access individual item context from loops processed above
        result = result.replace(
          /\{\{>\s*([^}]+)\}\}/g,
          (match, partialName) => {
            const cleanPartialName = partialName.trim();
            const partial =
              self.partials.get(cleanPartialName) ||
              self.templates.get(cleanPartialName);
            if (!partial) {
              logWarn(
                `[TemplateSystem] Partial "${cleanPartialName}" not found`
              );
              return `<!-- Partial "${cleanPartialName}" not found -->`;
            }

            // ‚úÖ FIX: Merge default data for the partial with current data
            const partialDefaults =
              self.getDefaultTemplateData(cleanPartialName);
            const mergedPartialData = { ...partialDefaults, ...data };

            logDebug(
              `Processing partial "${cleanPartialName}" with merged data:`,
              mergedPartialData
            );

            // Recursively process the partial with merged data
            return processTemplate(partial, mergedPartialData);
          }
        );

        // Process {{#if}} conditionals with else support
        result = result.replace(
          /\{\{#if\s+([^}]+)\}\}([\s\S]*?)(?:\{\{else\}\}([\s\S]*?))?\{\{\/if\}\}/g,
          (match, condition, truthy, falsy = "") => {
            const value = self.evaluateCondition(condition.trim(), data);
            return value
              ? processTemplate(truthy, data)
              : processTemplate(falsy, data);
          }
        );

        // PHASE 4B: Process {{#block}} directives - extract content only
        result = result.replace(
          /\{\{#block\s+"([^"]+)"\}\}([\s\S]*?)\{\{\/block\}\}/g,
          (match, blockName, content) => {
            // For final rendering, we just want the content inside the block
            logDebug(
              `[TemplateSystem] Processing block directive: ${blockName}`
            );
            return processTemplate(content.trim(), data);
          }
        );

        // Process {{{raw}}} unescaped content
        result = result.replace(/\{\{\{([^}]+)\}\}\}/g, (match, expression) => {
          const value = self.getNestedValue(data, expression.trim());
          return value != null ? String(value) : "";
        });

        // Process {{variable}} substitutions with filters AND {{helper}} calls
        result = result.replace(/\{\{([^}#\/]+)\}\}/g, (match, expression) => {
          // Clean the expression
          const cleanExpression = expression.trim();

          logDebug("Processing expression:", {
            expression: cleanExpression,
            match,
          });

          // Check for helper functions (contains spaces and not just filter syntax)
          if (cleanExpression.includes(" ") && !cleanExpression.includes("|")) {
            logDebug("Detected helper call:", cleanExpression);
            return self.processHelper(cleanExpression, data);
          }

          // Handle variable with filters: variable | filter1 | filter2
          const [variable, ...filters] = cleanExpression
            .split("|")
            .map((s) => s.trim());

          logDebug("Processing variable:", {
            variable,
            filters,
            expression: cleanExpression,
          });

          // Check if the variable part (before any filters) is a helper call
          if (variable.includes(" ")) {
            logDebug("Variable part is helper call:", variable);
            let helperResult = self.processHelper(variable, data);

            // Apply filters to helper result
            for (const filter of filters) {
              const [filterName, ...args] = filter
                .split(":")
                .map((s) => s.trim());
              const filterFn = self.filters.get(filterName);
              if (filterFn) {
                logDebug(
                  "Applying filter to helper result:",
                  filterName,
                  "with args:",
                  args
                );
                helperResult = filterFn(helperResult, ...args);
                logDebug("Value after filter:", helperResult);
              } else {
                logWarn(`[TemplateSystem] Filter "${filterName}" not found`);
              }
            }

            return self.escapeHtml(helperResult);
          }

          // Handle simple variable lookup
          let value = self.getNestedValue(data, variable);
          logDebug("Initial value:", value);

          // Apply filters to variable value
          for (const filter of filters) {
            const [filterName, ...args] = filter
              .split(":")
              .map((s) => s.trim());
            const filterFn = self.filters.get(filterName);
            if (filterFn) {
              logDebug("Applying filter:", filterName, "with args:", args);
              value = filterFn(value, ...args);
              logDebug("Value after filter:", value);
            } else {
              logWarn(`[TemplateSystem] Filter "${filterName}" not found`);
            }
          }

          const escaped = self.escapeHtml(value);
          logDebug("Final escaped value:", escaped);
          return escaped;
        });

        return result;
      }, "processTemplate");

      return (data) => processTemplate(template, data);
    }

    /**
     * Evaluate conditional expressions for {{#if}} directive processing.
     *
     * Supports multiple condition types with proper operator precedence and
     * variable resolution. Conditions are evaluated against the current data
     * context and return boolean results for conditional rendering.
     *
     * Supported condition types:
     * - Negation: !variable (NOT operator, evaluated first)
     * - Equality: variable == 'value' or variable === 'value'
     * - Inequality: variable != 'value' or variable !== 'value'
     * - Comparisons: variable > 5, variable >= 5, variable < 5, variable <= 5
     * - Truthiness: variable (checks if value is truthy)
     *
     * All variables are resolved via getNestedValue() which supports dot notation
     * and array indices. String literals must be quoted ('single' or "double").
     *
     * @param {string} condition - Condition expression to evaluate
     * @param {Object} data - Current data context for variable resolution
     * @returns {boolean} True if condition passes, false otherwise
     *
     * @example
     * evaluateCondition('!isHidden', { isHidden: false }); // true
     * evaluateCondition('count > 5', { count: 10 }); // true
     * evaluateCondition('name === "Admin"', { name: "Admin" }); // true
     */
    evaluateCondition(condition, data) {
      // Handle not operator
      if (condition.startsWith("!")) {
        return !this.evaluateCondition(condition.slice(1), data);
      }

      // Handle equality: variable == 'value' or variable === 'value'
      const equalityMatch = condition.match(
        /^(\S+)\s*(===?)\s*['"]([^'"]+)['"]$/
      );
      if (equalityMatch) {
        const [, variable, operator, value] = equalityMatch;
        const varValue = this.getNestedValue(data, variable);
        return operator === "===" ? varValue === value : varValue == value;
      }

      // Handle inequality: variable != 'value'
      const inequalityMatch = condition.match(
        /^(\S+)\s*!==?\s*['"]([^'"]+)['"]$/
      );
      if (inequalityMatch) {
        const [, variable, value] = inequalityMatch;
        return this.getNestedValue(data, variable) !== value;
      }

      // Handle comparisons: variable > 5, variable <= 10
      const comparisonMatch = condition.match(/^(\S+)\s*([<>]=?)\s*(\d+)$/);
      if (comparisonMatch) {
        const [, variable, operator, value] = comparisonMatch;
        const varValue = Number(this.getNestedValue(data, variable));
        const numValue = Number(value);

        switch (operator) {
          case ">":
            return varValue > numValue;
          case ">=":
            return varValue >= numValue;
          case "<":
            return varValue < numValue;
          case "<=":
            return varValue <= numValue;
        }
      }

      // Simple truthiness
      return !!this.getNestedValue(data, condition);
    }

    /**
     * Process helper function calls with intelligent argument parsing.
     *
     * Helpers are template functions called with {{helperName arg1 arg2}} syntax.
     * This method parses the expression to extract the helper name and arguments,
     * handling quoted strings, numbers, and variable references correctly.
     *
     * Argument parsing supports:
     * - Quoted strings: "value" or 'value' (quotes preserved during parsing, removed before use)
     * - Numbers: 42, 3.14, 0 (converted to Number type)
     * - Variables: user.name (resolved via getNestedValue)
     * - Mixed types: {{formatSize 16 "px"}} ‚Üí formatSize(16, "px")
     *
     * The parser respects quote boundaries so spaces inside quoted strings
     * don't split arguments. After parsing, arguments are resolved to their
     * actual values before passing to the helper function.
     *
     * @param {string} expression - Helper expression (e.g., 'formatSize value "px"')
     * @param {Object} data - Current data context for variable resolution
     * @returns {string} String result from helper execution
     * @throws {Error} Does not throw - returns HTML comment on helper error
     *
     * @example
     * processHelper('formatId "My Section Title"', {});
     * // Returns: "my-section-title"
     *
     * @example
     * processHelper('formatSize fontSize "em"', { fontSize: 1.5 });
     * // Returns: "1.5em"
     */
    processHelper(expression, data) {
      // Enhanced parsing to handle quoted arguments correctly
      const parts = [];
      let current = "";
      let inQuotes = false;
      let quoteChar = "";

      for (let i = 0; i < expression.length; i++) {
        const char = expression[i];

        if ((char === '"' || char === "'") && !inQuotes) {
          inQuotes = true;
          quoteChar = char;
          current += char;
        } else if (char === quoteChar && inQuotes) {
          inQuotes = false;
          quoteChar = "";
          current += char;
        } else if (char === " " && !inQuotes) {
          if (current.trim()) {
            parts.push(current.trim());
            current = "";
          }
        } else {
          current += char;
        }
      }

      if (current.trim()) {
        parts.push(current.trim());
      }

      const helperName = parts[0];
      const args = parts.slice(1);

      logDebug("Processing helper:", { helperName, args, expression, parts });

      const helper = this.helpers.get(helperName);
      if (!helper) {
        logWarn(`[TemplateSystem] Helper "${helperName}" not found`);
        return `<!-- Helper "${helperName}" not found -->`;
      }

      try {
        const values = args.map((arg) => {
          // Handle quoted strings
          if (
            (arg.startsWith('"') && arg.endsWith('"')) ||
            (arg.startsWith("'") && arg.endsWith("'"))
          ) {
            return arg.slice(1, -1);
          }
          // Handle numbers
          if (!isNaN(arg) && arg !== "" && arg !== "0") {
            return Number(arg);
          }
          // Handle zero specifically
          if (arg === "0") {
            return 0;
          }
          // Handle variables
          return this.getNestedValue(data, arg);
        });

        logDebug("Helper values:", values);
        const result = helper(...values);
        logDebug("Helper result:", result);
        return String(result); // Ensure result is always a string
      } catch (error) {
        logError(`[TemplateSystem] Error in helper "${helperName}":`, error);
        return `<!-- Error in helper "${helperName}" -->`;
      }
    }

    /**
     * Safe nested property access with dot notation, array indices, and special variables.
     *
     * Retrieves values from nested object structures using string path notation.
     * Handles missing properties gracefully by returning empty string instead of
     * throwing errors. Supports multiple path formats and special loop variables.
     *
     * Path formats supported:
     * - Simple: "name" ‚Üí obj.name
     * - Nested: "user.profile.email" ‚Üí obj.user.profile.email
     * - Array indices: "items[0]" ‚Üí obj.items[0]
     * - Special variables: "@index", "@first", "@last" (set by {{#each}} loops)
     *
     * Return values:
     * - Found values: returned as-is (preserves type)
     * - Undefined/null: returns empty string ""
     * - Missing paths: returns empty string "" (graceful degradation)
     *
     * Debug logging shows path resolution steps when DEBUG log level enabled.
     *
     * @param {Object} obj - Object to traverse for value retrieval
     * @param {string} path - Property path with dot notation or array indices
     * @returns {*} Retrieved value, or empty string if path not found
     *
     * @example
     * getNestedValue({ user: { name: "John" } }, "user.name");
     * // Returns: "John"
     *
     * @example
     * getNestedValue({ items: ["a", "b"] }, "items[0]");
     * // Returns: "a"
     *
     * @example
     * getNestedValue({ "@index": 5 }, "@index");
     * // Returns: 5 (special loop variable)
     */
    getNestedValue(obj, path) {
      if (!path || typeof path !== "string") return "";
      if (path.startsWith("@")) return obj[path] !== undefined ? obj[path] : "";

      // Handle simple property access (no dots)
      if (!path.includes(".")) {
        const value = obj && obj[path] !== undefined ? obj[path] : "";
        logDebug(
          `Simple property access: ${path} = ${JSON.stringify(value)} from:`,
          obj
        );
        return value;
      }

      // Handle nested property access (with dots)
      const pathParts = path.split(".");
      const result = pathParts.reduce((current, part) => {
        if (current === null || current === undefined) return "";

        // Handle array index like items[0]
        const arrayMatch = part.match(/^(\w+)\[(\d+)\]$/);
        if (arrayMatch) {
          const [, arrayName, index] = arrayMatch;
          const array = current[arrayName];
          return Array.isArray(array) ? array[parseInt(index)] : "";
        }

        // Handle simple property access
        return current[part] !== undefined ? current[part] : "";
      }, obj);

      logDebug(`Nested property access: ${path} = ${JSON.stringify(result)}`);
      return result;
    }

    /**
     * HTML escape text content to prevent XSS injection attacks.
     *
     * Converts special HTML characters to their entity equivalents to safely
     * display user-provided content without executing embedded scripts or markup.
     * Uses browser's native textContent ‚Üí innerHTML conversion for reliable escaping.
     *
     * Escaping rules:
     * - & ‚Üí &amp;
     * - < ‚Üí &lt;
     * - > ‚Üí &gt;
     * - " ‚Üí &quot;
     * - ' ‚Üí &#39;
     *
     * Type handling:
     * - null/undefined ‚Üí empty string ""
     * - boolean ‚Üí "true" or "false"
     * - number ‚Üí string representation
     * - object ‚Üí converted to string then escaped
     *
     * This escaping is automatically applied to {{variable}} syntax.
     * Use {{{variable}}} (triple braces) to output raw HTML without escaping.
     *
     * @param {*} text - Content to escape (any type accepted)
     * @returns {string} HTML-safe escaped string
     *
     * @example
     * escapeHtml('<script>alert("xss")</script>');
     * // Returns: "&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;"
     *
     * @example
     * escapeHtml(null);
     * // Returns: ""
     *
     * @example
     * escapeHtml(42);
     * // Returns: "42"
     */
    escapeHtml(text) {
      if (text === null || text === undefined) return "";
      if (typeof text === "boolean") return text ? "true" : "false";
      if (typeof text === "number") return String(text);

      const div = document.createElement("div");
      div.textContent = String(text);
      return div.innerHTML;
    }

    // ===========================================================================================
    // HELPERS & FILTERS
    // ===========================================================================================
    // Template helper functions and value filters.
    // Helpers: {{formatDate date}}  Filters: {{value | uppercase}}

    /**
     * Register all default helper functions for template processing.
     *
     * Initialises the template engine with a comprehensive set of helper functions
     * that can be invoked within templates using {{helperName arg1 arg2}} syntax.
     * Helpers are distinct from filters: helpers are called as functions with
     * space-separated arguments, while filters use pipe syntax ({{value | filter}}).
     *
     * Helper categories:
     *
     * **Formatting Helpers:**
     * - formatPercent: Convert decimal to percentage string (0.75 ‚Üí "75%")
     * - formatSize: Append CSS unit to numeric value (1.5, "rem" ‚Üí "1.5rem")
     * - formatId: Convert text to kebab-case HTML ID (sanitised)
     *
     * **Logic Helpers:**
     * - equals: Strict equality comparison (a === b)
     * - notEquals: Strict inequality comparison (a !== b)
     * - greaterThan: Numeric comparison (a > b)
     * - lessThan: Numeric comparison (a < b)
     *
     * **Localisation Helpers:**
     * - britishSpelling: Transform American spelling to British (color ‚Üí colour)
     *
     * All helpers are stored in the this.helpers Map and can be extended at runtime
     * using registerHelper(). Helpers are processed during template compilation via
     * processHelper() when the compiler encounters space-separated expressions.
     *
     * Template usage syntax:
     * - {{helperName arg1 arg2 arg3}}
     * - Arguments are resolved from template data context
     * - Results are automatically HTML-escaped for safety
     *
     * @returns {void} Helpers registered in this.helpers Map
     *
     * @example
     * // In template:
     * // {{formatPercent completionRate}}
     * // With data: { completionRate: 0.856 }
     * // Renders: "86%"
     *
     * @example
     * // Logic helper in template:
     * // {{#if equals status "active"}}Active User{{/if}}
     * // With data: { status: "active" }
     * // Renders: "Active User"
     */
    setupDefaultHelpers() {
      // Formatting helpers

      /**
       * Helper: formatPercent - Convert decimal value to percentage string with rounding.
       *
       * Transforms decimal probability/ratio values (0-1 range) into human-readable
       * percentage strings with % symbol. Automatically rounds to nearest whole number
       * for cleaner display in accessibility controls and progress indicators.
       *
       * Processing: parseFloat ‚Üí multiply by 100 ‚Üí round ‚Üí append "%"
       *
       * Usage in templates: {{formatPercent value}}
       *
       * @param {number|string} value - Decimal value to format (e.g., 0.75)
       * @returns {string} Percentage string with % symbol (e.g., "75%")
       *
       * @example
       * {{formatPercent 0.856}}
       * // Returns: "86%"
       *
       * @example
       * {{formatPercent completionRate}}
       * // With completionRate = 0.333, returns: "33%"
       */
      this.helpers.set(
        "formatPercent",
        (value) => Math.round(parseFloat(value) * 100) + "%"
      );
      /**
       * Helper: formatSize - Append CSS unit to numeric value.
       *
       * Converts numeric size values into CSS-compatible size strings by appending
       * the specified unit. Default unit is "em" for scalable typography. Commonly
       * used in accessibility controls for font-size, line-height, spacing adjustments.
       *
       * Usage in templates: {{formatSize value}} or {{formatSize value "rem"}}
       *
       * @param {number|string} value - Numeric size value
       * @param {string} [unit="em"] - CSS unit to append (default: "em")
       * @returns {string} Size string with unit (e.g., "1.5em")
       *
       * @example
       * {{formatSize 1.5}}
       * // Returns: "1.5em"
       *
       * @example
       * {{formatSize 24 "px"}}
       * // Returns: "24px"
       */
      this.helpers.set("formatSize", (value, unit = "em") => value + unit);

      /**
       * Helper: formatId - Transform text into valid kebab-case HTML ID attribute.
       *
       * Sanitises arbitrary text into valid HTML ID strings using kebab-case convention.
       * Removes all non-alphanumeric characters, converts to lowercase, replaces spaces
       * with hyphens, and ensures no leading/trailing hyphens. Critical for generating
       * accessible anchor links and form control IDs from section titles or labels.
       *
       * Processing steps:
       * 1. Convert to lowercase
       * 2. Replace non-alphanumeric with hyphens
       * 3. Collapse multiple hyphens to single hyphen
       * 4. Remove leading/trailing hyphens
       *
       * Usage in templates: {{formatId text}}
       *
       * @param {string} text - Text to transform into HTML ID
       * @returns {string} Sanitised kebab-case ID string
       *
       * @example
       * {{formatId "Section 1: Introduction"}}
       * // Returns: "section-1-introduction"
       *
       * @example
       * {{formatId "Math & Science!!"}}
       * // Returns: "math-science"
       */
      this.helpers.set("formatId", (text) =>
        String(text)
          .toLowerCase()
          .replace(/[^a-z0-9]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-|-$/g, "")
      );

      // Logic helpers

      /**
       * Helper: equals - Strict equality comparison for template conditionals.
       *
       * Performs JavaScript strict equality (===) comparison between two values.
       * Used within {{#if}} conditionals to enable comparison-based conditional
       * rendering. Returns boolean true/false for template conditional evaluation.
       *
       * Usage in templates: {{#if equals value1 value2}}
       *
       * @param {*} a - First value to compare
       * @param {*} b - Second value to compare
       * @returns {boolean} True if strictly equal (a === b), false otherwise
       *
       * @example
       * {{#if equals status "active"}}
       *   User is active
       * {{/if}}
       */
      this.helpers.set("equals", (a, b) => a === b);

      /**
       * Helper: notEquals - Strict inequality comparison for template conditionals.
       *
       * Performs JavaScript strict inequality (!==) comparison between two values.
       * Inverse of equals helper. Returns boolean for template conditional evaluation.
       *
       * Usage in templates: {{#if notEquals value1 value2}}
       *
       * @param {*} a - First value to compare
       * @param {*} b - Second value to compare
       * @returns {boolean} True if not strictly equal (a !== b), false otherwise
       *
       * @example
       * {{#if notEquals userRole "admin"}}
       *   Limited access
       * {{/if}}
       */
      this.helpers.set("notEquals", (a, b) => a !== b);

      /**
       * Helper: greaterThan - Numeric greater-than comparison for conditionals.
       *
       * Performs JavaScript greater-than (>) comparison between two values.
       * Typically used for numeric threshold checks in conditional rendering.
       *
       * Usage in templates: {{#if greaterThan count 10}}
       *
       * @param {number} a - First numeric value
       * @param {number} b - Second numeric value (threshold)
       * @returns {boolean} True if a > b, false otherwise
       *
       * @example
       * {{#if greaterThan score 90}}
       *   Grade: A
       * {{/if}}
       */
      this.helpers.set("greaterThan", (a, b) => a > b);

      /**
       * Helper: lessThan - Numeric less-than comparison for conditionals.
       *
       * Performs JavaScript less-than (<) comparison between two values.
       * Typically used for numeric threshold checks in conditional rendering.
       *
       * Usage in templates: {{#if lessThan remaining 5}}
       *
       * @param {number} a - First numeric value
       * @param {number} b - Second numeric value (threshold)
       * @returns {boolean} True if a < b, false otherwise
       *
       * @example
       * {{#if lessThan stockLevel 10}}
       *   Low stock warning
       * {{/if}}
       */
      this.helpers.set("lessThan", (a, b) => a < b);

      // British spelling helper

      /**
       * Helper: britishSpelling - Transform American spelling to British English.
       *
       * Performs systematic American ‚Üí British spelling transformations for common
       * words and patterns. Used to ensure consistent British English throughout
       * generated documents per project requirements. Handles both lowercase and
       * capitalised variants.
       *
       * Transformations applied:
       * - color ‚Üí colour (and capitalised Color ‚Üí Colour)
       * - -ize ‚Üí -ise (word endings: realize ‚Üí realise)
       * - -izing ‚Üí -ising (gerunds: customizing ‚Üí customising)
       * - -ized ‚Üí -ised (past tense: customized ‚Üí customised)
       * - customize ‚Üí customise (explicit common words)
       *
       * Uses negative lookahead (?![a-z]) to only match word endings, preventing
       * incorrect transformations in the middle of words.
       *
       * Usage in templates: {{britishSpelling text}}
       *
       * @param {string} text - Text containing American spelling
       * @returns {string} Text converted to British spelling
       *
       * @example
       * {{britishSpelling "Customize the color scheme"}}
       * // Returns: "Customise the colour scheme"
       *
       * @example
       * {{britishSpelling "Organizing and prioritizing tasks"}}
       * // Returns: "Organising and prioritising tasks"
       */
      this.helpers.set("britishSpelling", (text) => {
        return String(text)
          .replace(/color/g, "colour")
          .replace(/Color/g, "Colour")
          .replace(/ize(?![a-z])/g, "ise")
          .replace(/izing(?![a-z])/g, "ising")
          .replace(/ized(?![a-z])/g, "ised")
          .replace(/customize/g, "customise")
          .replace(/Customize/g, "Customise");
      });

      logDebug(`Registered ${this.helpers.size} default helpers`);
    }

    /**
     * Register all default filter functions for template processing.
     *
     * Initialises the template engine with a comprehensive set of filter functions
     * that can be applied to variable values using pipe syntax: {{variable | filter}}.
     * Filters are distinct from helpers: filters transform single values using pipes,
     * while helpers are called as functions with space-separated arguments.
     *
     * Filter categories:
     *
     * **Text Transformation Filters:**
     * - uppercase: Convert text to UPPERCASE
     * - lowercase: Convert text to lowercase
     * - capitalise: Capitalise first letter only (British spelling)
     *
     * **String Manipulation Filters:**
     * - truncate: Limit text length with ellipsis (default 50 chars)
     * - default: Provide fallback value for null/undefined/empty
     *
     * All filters are stored in the this.filters Map and can be extended at runtime
     * using registerFilter(). Filters are processed during template compilation when
     * the compiler encounters pipe syntax within variable expressions.
     *
     * Filters can be chained for multiple transformations:
     * {{name | uppercase | truncate:20}}
     *
     * Template usage syntax:
     * - {{variable | filterName}}
     * - {{variable | filterName:arg1:arg2}}
     * - {{variable | filter1 | filter2}}
     *
     * @returns {void} Filters registered in this.filters Map
     *
     * @example
     * // In template:
     * // {{title | uppercase | truncate:30}}
     * // With data: { title: "a very long title that needs shortening" }
     * // Renders: "A VERY LONG TITLE THAT NEE..."
     *
     * @example
     * // Default filter for optional values:
     * // {{username | default:"Guest"}}
     * // With data: { username: null }
     * // Renders: "Guest"
     */
    setupDefaultFilters() {
      /**
       * Filter: uppercase - Convert value to uppercase for emphasis or headers.
       *
       * Transforms any value to uppercase string. Automatically converts non-string
       * values to strings before transformation. Used with pipe syntax in templates.
       * Commonly applied to headers, labels, or emphasis text in accessibility controls.
       *
       * Usage in templates: {{variable | uppercase}}
       *
       * @param {*} value - Value to transform (any type accepted)
       * @returns {string} Uppercase string representation
       *
       * @example
       * {{title | uppercase}}
       * // With title = "important", returns: "IMPORTANT"
       *
       * @example
       * {{name | uppercase | truncate:20}}
       * // Filters chained: uppercase first, then truncate
       */
      this.filters.set("uppercase", (value) => String(value).toUpperCase());

      /**
       * Filter: lowercase - Convert value to lowercase for consistent formatting.
       *
       * Transforms any value to lowercase string. Automatically converts non-string
       * values to strings before transformation. Used for normalising text display,
       * creating consistent CSS class names, or matching user input case-insensitively.
       *
       * Usage in templates: {{variable | lowercase}}
       *
       * @param {*} value - Value to transform (any type accepted)
       * @returns {string} Lowercase string representation
       *
       * @example
       * {{email | lowercase}}
       * // With email = "USER@EXAMPLE.COM", returns: "user@example.com"
       */
      this.filters.set("lowercase", (value) => String(value).toLowerCase());

      /**
       * Filter: capitalise - Capitalise first letter only (British spelling).
       *
       * Transforms text to have uppercase first character with remaining characters
       * unchanged. Uses British spelling "capitalise" per project conventions.
       * Useful for proper noun formatting, sentence-case headings, or label formatting.
       *
       * Note: Only capitalises first character - does not convert remaining text to
       * lowercase. For full sentence case, combine with lowercase:
       * {{text | lowercase | capitalise}}
       *
       * Usage in templates: {{variable | capitalise}}
       *
       * @param {*} value - Value to transform (any type accepted)
       * @returns {string} String with first character capitalised
       *
       * @example
       * {{name | capitalise}}
       * // With name = "john", returns: "John"
       *
       * @example
       * {{title | lowercase | capitalise}}
       * // With title = "INTRODUCTION", returns: "Introduction"
       */
      this.filters.set(
        "capitalise",
        (value) =>
          String(value).charAt(0).toUpperCase() + String(value).slice(1)
      );
      /**
       * Filter: truncate - Limit text length with ellipsis suffix.
       *
       * Shortens long text to specified maximum length, appending "..." if truncated.
       * Default length is 50 characters. Preserves full text if under limit.
       * Critical for maintaining layout in space-constrained UI components like
       * table cells, navigation menus, or preview snippets.
       *
       * Length parameter can be specified using colon syntax in templates.
       *
       * Usage in templates: {{variable | truncate}} or {{variable | truncate:30}}
       *
       * @param {*} value - Value to truncate (converted to string)
       * @param {number} [length=50] - Maximum length before truncation
       * @returns {string} Truncated string with "..." if length exceeded, original if not
       *
       * @example
       * {{description | truncate}}
       * // With 60-char description, returns: first 50 chars + "..."
       *
       * @example
       * {{title | truncate:20}}
       * // Custom length: truncates to 20 characters with "..."
       *
       * @example
       * {{name | truncate:100}}
       * // With name = "John", returns: "John" (under limit, no truncation)
       */
      this.filters.set("truncate", (value, length = 50) => {
        const str = String(value);
        return str.length > length ? str.slice(0, length) + "..." : str;
      });

      /**
       * Filter: default - Provide fallback value for null/undefined/falsy values.
       *
       * Returns the original value if truthy, otherwise returns the specified default
       * value. Uses JavaScript OR (||) operator, so treats all falsy values
       * (null, undefined, 0, false, empty string) as missing and applies default.
       * Essential for handling optional data fields in templates without errors.
       *
       * Default value is specified using colon syntax in templates.
       *
       * Usage in templates: {{variable | default:"fallback text"}}
       *
       * @param {*} value - Value to check (if truthy, return as-is)
       * @param {*} defaultValue - Fallback value to return if value is falsy
       * @returns {*} Original value if truthy, defaultValue if falsy
       *
       * @example
       * {{username | default:"Guest"}}
       * // With username = null, returns: "Guest"
       * // With username = "John", returns: "John"
       *
       * @example
       * {{count | default:0}}
       * // With count = undefined, returns: 0
       *
       * @example
       * {{email | default:"No email provided"}}
       * // With email = "", returns: "No email provided" (empty string is falsy)
       */
      this.filters.set(
        "default",
        (value, defaultValue) => value || defaultValue
      );

      logDebug(`Registered ${this.filters.size} default filters`);
    }

    // ===========================================================================================
    // BACKWARD COMPATIBILITY WITH CURRENT SYSTEM
    // ===========================================================================================

    /**
     * Render templates with data - Legacy compatibility wrapper for current system.
     * Delegates to: render() for actual template processing
     *
     * This method provides backward compatibility by automatically merging user-provided
     * data with default template data and wrapping the render operation with performance
     * monitoring. It replaces the previous string concatenation approach with proper
     * Handlebars template rendering while maintaining the same API surface.
     *
     * The method automatically:
     * - Fetches default data appropriate for the template type
     * - Merges user data with defaults (user data takes precedence)
     * - Wraps rendering in performance measurement
     * - Logs debug information about the rendering operation
     *
     * @param {string} templateName - Name of the template to render (e.g., 'readingToolsSection')
     * @param {Object} data - User-provided data to merge with defaults (optional, defaults to empty object)
     * @returns {string} Rendered HTML string with all variables substituted
     * @throws {Error} [TemplateSystem] If template not found or rendering fails
     *
     * @example
     * // Render with minimal data (uses all defaults)
     * const html = engine.renderTemplate('readingToolsSection');
     *
     * @example
     * // Render with custom data (overrides defaults)
     * const html = engine.renderTemplate('themeToggleSection', {
     *   icon: '‚òÄÔ∏è',
     *   text: 'Light',
     *   isDarkMode: true
     * });
     */
    renderTemplate(templateName, data = {}) {
      // Provide default data for common templates
      const defaultData = this.getDefaultTemplateData(templateName);
      const mergedData = { ...defaultData, ...data };

      logDebug(`Rendering template "${templateName}" with data:`, mergedData);

      return measurePerformance(
        () => this.render(templateName, mergedData),
        templateName
      )();
    }

    /**
     * Get default template data with British spelling for all accessibility controls.
     *
     * This critical method provides comprehensive default data for all accessibility
     * control templates, ensuring that exported documents work correctly even when
     * minimal data is provided. It maintains British spelling throughout (e.g.,
     * 'customise' not 'customize') and includes sensible defaults for:
     *
     * - Reading tools (fonts, spacing, widths)
     * - Theme controls (light/dark mode)
     * - MathJax accessibility (zoom, screen readers, keyboard navigation)
     * - Document structure (table of contents, sidebar)
     * - Print and reset controls
     *
     * The defaults are designed to meet WCAG 2.2 AA accessibility standards and
     * provide an excellent user experience out of the box. Variable font support
     * includes the Annotation Mono font with weight ranges 100-1000.
     *
     * @param {string} templateName - Name of template to get defaults for
     * @returns {Object} Default data object for the template, or empty object if no defaults defined
     * @returns {Object} defaults.readingToolsSection - Font, spacing, and width options
     * @returns {Array} defaults.readingToolsSection.fontOptions - 11 font choices including variable fonts
     * @returns {Array} defaults.readingToolsSection.widthOptions - 4 reading width options
     * @returns {Object} defaults.themeToggleSection - Light/dark theme toggle defaults
     * @returns {Object} defaults.mathJaxAccessibilityControls - MathJax interaction settings
     * @returns {Array} defaults.mathJaxAccessibilityControls.zoomOptions - 3 zoom trigger modes
     *
     * @example
     * // Get defaults for reading tools
     * const data = engine.getDefaultTemplateData('readingToolsSection');
     * // Returns: { fontOptions: [...11 fonts], widthOptions: [...4 widths], ... }
     *
     * @example
     * // Get defaults for theme toggle
     * const data = engine.getDefaultTemplateData('themeToggleSection');
     * // Returns: { icon: 'üåô', text: 'Dark', ariaLabel: 'Switch to dark mode', isDarkMode: false }
     */
    getDefaultTemplateData(templateName) {
      const defaults = {
        readingToolsSection: {
          fontOptions: [
            {
              value: "Verdana, sans-serif",
              label: "Verdana (sans-serif)",
              selected: true,
            },
            {
              value: "Arial, sans-serif",
              label: "Arial (sans-serif)",
              selected: false,
            },
            {
              value: "Tahoma, sans-serif",
              label: "Tahoma (sans-serif)",
              selected: false,
            },
            {
              value: "'Trebuchet MS', sans-serif",
              label: "Trebuchet MS (sans-serif)",
              selected: false,
            },
            {
              value: "OpenDyslexic, sans-serif",
              label: "OpenDyslexic ('dyslexia-friendly')",
              selected: false,
            },
            // ‚úÖ VARIABLE FONT with weight options
            {
              value: "Annotation Mono, monospace",
              label: "Annotation Mono (variable monospace)",
              selected: false,
              isVariable: true, // ‚úÖ Flag for advanced features
              weightRange: "100-1000",
              supportsItalic: true,
            },
            {
              value: "'Times New Roman', serif",
              label: "Times New Roman (serif)",
              selected: false,
            },
            {
              value: "Georgia, serif",
              label: "Georgia (serif)",
              selected: false,
            },
            {
              value: "Garamond, serif",
              label: "Garamond (serif)",
              selected: false,
            },
            {
              value: "'Courier New', monospace",
              label: "Courier New (monospace)",
              selected: false,
            },
            {
              value: "'Brush Script MT', cursive",
              label: "Brush Script MT (cursive)",
              selected: false,
            },
          ],
          // ‚úÖ ADD: Variable font weight options
          variableFontWeights: [
            { value: "300", label: "Light" },
            { value: "400", label: "Regular" },
            { value: "500", label: "Medium" },
            { value: "600", label: "Semi-Bold" },
            { value: "700", label: "Bold" },
            { value: "800", label: "Extra Bold" },
          ],
          widthOptions: [
            { value: "full", label: "Full width", selected: false },
            { value: "wide", label: "Wide", selected: false },
            {
              value: "narrow",
              label: "Narrow",
              selected: true,
            },
            {
              value: "extra-narrow",
              label: "Extra narrow",
              selected: false,
            },
          ],
          fontSize: 1.0,
          lineHeight: 1.6,
          paragraphSpacing: 1.0,
          wordSpacing: 0,
          letterSpacing: 0,
        },
        themeToggleSection: {
          icon: "üåô",
          text: "Dark",
          ariaLabel: "Switch to dark mode",
          isDarkMode: false,
        },
        mathJaxAccessibilityControls: {
          zoomOptions: [
            {
              id: "zoom-click",
              value: "Click",
              label: "Single click to zoom",
              checked: true,
              description:
                "Click once on any equation to zoom in for better readability",
            },
            {
              id: "zoom-doubleclick",
              value: "DoubleClick",
              label: "Double click to zoom",
              checked: false,
              description:
                "Double-click on any equation to zoom in for better readability",
            },
            {
              id: "zoom-nozoom",
              value: "NoZoom",
              label: "Zoom disabled",
              checked: false,
              description:
                "Zoom functionality is disabled - equations display at normal size",
            },
          ],
          zoomScale: 200,
          assistiveMathML: true,
          tabNavigation: true,
          usageInstructions: [
            {
              type: "Right-click",
              instruction: "Access MathJax context menu for additional options",
            },
            {
              type: "Keyboard",
              instruction:
                "Use Tab to navigate between equations when tab navigation is enabled",
            },
            {
              type: "Screen readers",
              instruction:
                "Assistive MathML provides spoken mathematical content",
            },
          ],
        },
        printButtonSection: {},
        resetControlsSection: {},
        tableOfContents: {
          sections: [],
        },
        // Add missing ones
        integratedDocumentSidebar: {
          // This template uses partials, so it inherits their defaults
        },
        // Default values for controls to fix NaN issues
        fontOption: {},
        widthOption: {},
        zoomOption: {},
      };

      return defaults[templateName] || {};
    }

    // ===========================================================================================
    // VALIDATION AND DEBUGGING
    // ===========================================================================================

    /**
     * Validate Handlebars template syntax for common errors before rendering.
     *
     * Performs static analysis of template syntax to catch common errors:
     * - Mismatched {{#if}} and {{#each}} block helpers (unclosed tags)
     * - Invalid nested syntax (double opening braces)
     *
     * This is a development and debugging tool that helps identify template
     * errors before they cause runtime failures. It's particularly useful
     * when loading external templates or modifying template strings.
     *
     * Note: This performs basic syntax checking only and does not validate:
     * - Variable names or data structure
     * - Helper function availability
     * - Partial template references
     *
     * @param {string} templateName - Name of template to validate
     * @returns {Object} Validation result object
     * @returns {boolean} result.valid - True if template passes validation
     * @returns {string} [result.error] - Error message if template not found
     * @returns {Array<string>} [result.errors] - Array of syntax errors found (empty if valid)
     *
     * @example
     * const result = engine.validateTemplate('readingToolsSection');
     * if (!result.valid) {
     *   console.error('Template errors:', result.errors);
     * }
     * // Returns: { valid: true, errors: [] }
     *
     * @example
     * // Validating a template with mismatched tags
     * const result = engine.validateTemplate('brokenTemplate');
     * // Returns: {
     * //   valid: false,
     * //   errors: ['Mismatched {{#if}} or {{#each}} tags (2 open, 1 close)']
     * // }
     */
    validateTemplate(templateName) {
      const template = this.templates.get(templateName);
      if (!template) {
        return { valid: false, error: `Template "${templateName}" not found` };
      }

      const errors = [];

      // Check for unclosed tags
      const openTags = (template.match(/\{\{#(if|each)[^}]*\}\}/g) || [])
        .length;
      const closeTags = (template.match(/\{\{\/(if|each)\}\}/g) || []).length;
      if (openTags !== closeTags) {
        errors.push(
          `Mismatched {{#if}} or {{#each}} tags (${openTags} open, ${closeTags} close)`
        );
      }

      // Check for invalid syntax
      const invalidSyntax = template.match(/\{\{[^}]*\{\{/g);
      if (invalidSyntax) {
        errors.push(`Invalid nested template syntax found`);
      }

      return {
        valid: errors.length === 0,
        errors,
      };
    }

    /**
     * Debug template rendering with comprehensive logging and validation.
     * Delegates to: validateTemplate() for syntax checking, render() for actual rendering
     *
     * This development and debugging tool provides detailed visibility into the
     * template rendering process:
     * - Logs the template name and input data
     * - Validates template syntax before attempting render
     * - Catches and logs rendering errors gracefully
     * - Provides a preview of the rendered output
     * - Returns null on failure instead of throwing errors
     *
     * Use this method during development to troubleshoot template issues or
     * verify that templates render correctly with specific data. It's particularly
     * useful when debugging complex nested templates or testing data structures.
     *
     * @param {string} templateName - Name of template to render in debug mode
     * @param {Object} data - Data to pass to template (optional, defaults to empty object)
     * @returns {string|null} Rendered HTML string on success, null on validation or render failure
     *
     * @example
     * // Debug render a template
     * const html = engine.debugRender('readingToolsSection', { fontSize: 1.2 });
     * // Console output:
     * // === Debug render for template: readingToolsSection ===
     * // Input data: { fontSize: 1.2 }
     * // Render successful, length: 4523
     * // Output preview: <section id="reading-tools" class="accessibility-cont...
     *
     * @example
     * // Debug render with validation failure
     * const html = engine.debugRender('brokenTemplate');
     * // Console output:
     * // === Debug render for template: brokenTemplate ===
     * // [ERROR] Template validation failed: ['Mismatched {{#if}} tags']
     * // Returns: null
     */
    debugRender(templateName, data = {}) {
      logInfo(`=== Debug render for template: ${templateName} ===`);
      logInfo("Input data:", data);

      const validation = this.validateTemplate(templateName);
      if (!validation.valid) {
        logError(
          "[TemplateSystem] Template validation failed:",
          validation.errors
        );
        return null;
      }

      try {
        const result = this.render(templateName, data);
        logInfo("Render successful, length:", result.length);
        logDebug("Output preview:", result.substring(0, 200) + "...");
        return result;
      } catch (error) {
        logError("[TemplateSystem] Render failed:", error);
        return null;
      }
    }

    // ===========================================================================================
    // EXTERNAL TEMPLATE LOADING (FUTURE ENHANCEMENT)
    // ===========================================================================================

    /**
     * Load templates from external files - Legacy method that now delegates to global cache.
     * Delegates to: GlobalTemplateCache.ensureTemplatesLoaded() for actual loading
     *
     * This method maintains backward compatibility with code that used to load
     * templates directly from files. It now leverages the singleton GlobalTemplateCache
     * for improved performance and memory efficiency, preventing duplicate file loads
     * across multiple template engine instances.
     *
     * The method:
     * 1. Triggers global cache loading (singleton pattern, only loads once)
     * 2. Maps requested filenames to internal template names
     * 3. Copies templates from global cache to this instance
     * 4. Returns detailed load results with success/failure breakdown
     *
     * Note: This is a legacy compatibility method. New code should use
     * initializeFromGlobalCache() or ensureTemplatesLoaded() directly.
     *
     * @param {Array<string>} templateFiles - Array of template filenames to load (e.g., ['reading-tools-section.html'])
     * @returns {Promise<Object>} Load results object
     * @returns {Array<string>} result.loaded - Successfully loaded template names
     * @returns {Array<Object>} result.failed - Failed loads with file name and error
     *
     * @example
     * const results = await engine.loadExternalTemplates([
     *   'reading-tools-section.html',
     *   'theme-toggle-section.html'
     * ]);
     * // Returns: {
     * //   loaded: ['readingToolsSection', 'themeToggleSection'],
     * //   failed: []
     * // }
     *
     * @example
     * // With some failures
     * const results = await engine.loadExternalTemplates(['nonexistent.html']);
     * // Returns: {
     * //   loaded: [],
     * //   failed: [{ file: 'nonexistent.html', error: 'Not found in global cache' }]
     * // }
     */
    async loadExternalTemplates(templateFiles) {
      logInfo("üîÑ Loading external templates via global cache:", templateFiles);

      // Use global cache for efficiency
      const results = await GlobalTemplateCache.ensureTemplatesLoaded();

      // Copy requested templates from global cache to instance
      const instanceResults = { loaded: [], failed: [] };

      templateFiles.forEach((fileName) => {
        const templateName =
          GlobalTemplateCache.mapExternalFilenameToTemplateName(fileName);

        if (GlobalTemplateCache.hasTemplate(templateName)) {
          const content = GlobalTemplateCache.getTemplate(templateName);
          this.templates.set(templateName, content);
          this.compiledTemplates.delete(templateName); // Clear cache
          instanceResults.loaded.push(templateName);
          logDebug(`üìã Copied ${templateName} from global cache`);
        } else {
          instanceResults.failed.push({
            file: fileName,
            error: "Not found in global cache",
          });
          logWarn(
            `[TemplateSystem] ‚ö†Ô∏è Template ${fileName} not found in global cache`
          );
        }
      });

      return instanceResults;
    }

    /**
     * Map external template filenames to internal template names.
     * Delegates to: GlobalTemplateCache.mapExternalFilenameToTemplateName()
     *
     * This method provides a consistent naming convention between external template
     * files (kebab-case HTML files) and internal template names (camelCase identifiers).
     *
     * The mapping is maintained in the GlobalTemplateCache singleton and includes:
     * - Main templates (e.g., 'reading-tools-section.html' ‚Üí 'readingToolsSection')
     * - Partial templates (e.g., 'partials/font-option.html' ‚Üí 'fontOption')
     * - Special templates (e.g., 'embedded-fonts.html' ‚Üí 'embedded-fonts')
     *
     * For unmapped files, it strips the file extension as a fallback.
     *
     * @param {string} fileName - External template filename (e.g., 'theme-toggle-section.html')
     * @returns {string} Internal template name (e.g., 'themeToggleSection')
     *
     * @example
     * const name = engine.mapExternalFilenameToTemplateName('reading-tools-section.html');
     * // Returns: 'readingToolsSection'
     *
     * @example
     * // Partial templates
     * const name = engine.mapExternalFilenameToTemplateName('partials/font-option.html');
     * // Returns: 'fontOption'
     *
     * @example
     * // Unmapped file (fallback behaviour)
     * const name = engine.mapExternalFilenameToTemplateName('custom-template.html');
     * // Returns: 'custom-template'
     */
    mapExternalFilenameToTemplateName(fileName) {
      return GlobalTemplateCache.mapExternalFilenameToTemplateName(fileName);
    }

    /**
     * Save template content to external file - Development and debugging helper.
     *
     * This utility method downloads a template's raw content as an HTML file,
     * useful for:
     * - Extracting templates for external editing
     * - Backing up template content
     * - Debugging template syntax issues
     * - Sharing templates between projects
     *
     * The method creates a downloadable Blob and triggers a browser download
     * using a temporary object URL. The URL is immediately revoked after use
     * to prevent memory leaks.
     *
     * Note: This is a development tool and should not be used in production
     * export pipelines. It triggers a browser download dialog.
     *
     * @param {string} templateName - Name of template to save (e.g., 'readingToolsSection')
     * @returns {void}
     * @throws {Error} Logs error if template not found (does not throw exception)
     *
     * @example
     * // Save a template for external editing
     * engine.saveTemplateAsFile('readingToolsSection');
     * // Downloads: readingToolsSection.html
     *
     * @example
     * // Attempting to save non-existent template
     * engine.saveTemplateAsFile('nonexistentTemplate');
     * // Logs error: [TemplateSystem] Cannot save: template "nonexistentTemplate" not found
     */
    saveTemplateAsFile(templateName) {
      const template = this.templates.get(templateName);
      if (!template) {
        logError(
          `[TemplateSystem] Cannot save: template "${templateName}" not found`
        );
        return;
      }

      const blob = new Blob([template], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${templateName}.html`;
      a.click();
      URL.revokeObjectURL(url);

      logInfo(`Template "${templateName}" downloaded as ${templateName}.html`);
    }

    /**
     * Load external templates using global cache during engine initialisation.
     * Delegates to: initializeFromGlobalCache() for actual loading
     *
     * OPTIMIZED: Uses singleton pattern to prevent duplicate loading across
     * multiple template engine instances.
     *
     * This initialization method is typically called during engine construction
     * to populate the instance with templates from the global cache. It:
     * - Leverages the GlobalTemplateCache singleton (loads files only once)
     * - Copies templates from global cache to this instance
     * - Provides fast initialization for subsequent engine instances
     * - Reduces memory footprint by sharing template content
     *
     * The global cache loads all templates from the /templates directory
     * on first access, then serves subsequent requests from memory.
     *
     * @returns {Promise<Object>} Initialization result from global cache
     * @returns {Array<string>} result.loaded - Successfully loaded template names
     * @returns {Array<Object>} result.failed - Failed loads with details
     *
     * @example
     * // Called automatically during engine construction
     * const engine = new EnhancedTemplateEngine();
     * // Internally calls: loadExternalTemplatesOnInit()
     * // Uses cached templates if already loaded
     */
    async loadExternalTemplatesOnInit() {
      logDebug("üìÑ Using global template cache for external templates...");
      return await this.initializeFromGlobalCache();
    }

    // ===========================================================================================
    // PERFORMANCE REPORTING
    // ===========================================================================================

    /**
     * Get comprehensive performance metrics for template rendering operations.
     *
     * Aggregates and calculates performance statistics from the global
     * performanceMetrics object, providing insights into:
     * - Template compilation cache effectiveness (hit rate)
     * - Average rendering performance (time per render)
     * - Total rendering workload (render count)
     * - Memory usage (template counts in caches)
     * - Global cache status (loaded state and template count)
     *
     * The cache hit rate is a critical metric - higher rates (>90%) indicate
     * efficient template reuse. Low hit rates suggest:
     * - Frequent template changes (cache invalidation)
     * - High variety of templates being rendered
     * - Potential opportunities for optimization
     *
     * Use this method to monitor template system performance during development
     * or to diagnose performance issues in production.
     *
     * @returns {Object} Performance metrics report
     * @returns {string} result.averageRenderTime - Average time per render (e.g., '2.45ms')
     * @returns {number} result.totalRenders - Total number of renders performed
     * @returns {string} result.cacheHitRate - Percentage of cache hits (e.g., '94.3%')
     * @returns {number} result.cacheHits - Number of successful cache lookups
     * @returns {number} result.cacheMisses - Number of cache misses (compile required)
     * @returns {number} result.templatesLoaded - Templates in this instance's cache
     * @returns {number} result.compiledTemplatesCount - Compiled templates in this instance
     * @returns {boolean} result.globalCacheLoaded - Whether global cache is initialised
     * @returns {number} result.globalTemplatesCount - Templates in global cache
     *
     * @example
     * const report = engine.getPerformanceReport();
     * console.log('Performance Report:', report);
     * // Returns: {
     * //   averageRenderTime: '2.45ms',
     * //   totalRenders: 127,
     * //   cacheHitRate: '94.3%',
     * //   cacheHits: 120,
     * //   cacheMisses: 7,
     * //   templatesLoaded: 15,
     * //   compiledTemplatesCount: 15,
     * //   globalCacheLoaded: true,
     * //   globalTemplatesCount: 15
     * // }
     */
    getPerformanceReport() {
      const avgRenderTime =
        performanceMetrics.renderCount > 0
          ? performanceMetrics.totalRenderTime / performanceMetrics.renderCount
          : 0;

      const cacheHitRate =
        performanceMetrics.cacheHits + performanceMetrics.cacheMisses > 0
          ? (performanceMetrics.cacheHits /
              (performanceMetrics.cacheHits + performanceMetrics.cacheMisses)) *
            100
          : 0;

      return {
        averageRenderTime: `${avgRenderTime.toFixed(2)}ms`,
        totalRenders: performanceMetrics.renderCount,
        cacheHitRate: `${cacheHitRate.toFixed(1)}%`,
        cacheHits: performanceMetrics.cacheHits,
        cacheMisses: performanceMetrics.cacheMisses,
        templatesLoaded: this.templates.size,
        compiledTemplatesCount: this.compiledTemplates.size,
        globalCacheLoaded: GlobalTemplateCache.isLoaded,
        globalTemplatesCount: GlobalTemplateCache.templates.size,
      };
    }

    /**
     * Clear this template engine instance's compiled template cache and reset performance metrics.
     *
     * This instance-level cleanup method:
     * - Clears all compiled templates (forces recompilation on next render)
     * - Resets performance counters to zero
     * - Does NOT affect the global template cache
     * - Does NOT affect raw template content (this.templates)
     *
     * Use this method when:
     * - Templates have been modified and need recompilation
     * - Testing performance from a clean state
     * - Freeing memory in long-running applications
     * - Resetting metrics for a new measurement period
     *
     * Note: This only affects this specific engine instance. Other instances
     * maintain their own separate caches. To clear all caches system-wide,
     * use the static clearAllCaches() method instead.
     *
     * @returns {void}
     *
     * @example
     * // Clear cache after template modification
     * engine.templates.set('myTemplate', '<div>{{newContent}}</div>');
     * engine.clearInstanceCache(); // Force recompilation
     * const html = engine.render('myTemplate', { newContent: 'Updated!' });
     *
     * @example
     * // Reset metrics for performance testing
     * engine.clearInstanceCache();
     * // All metrics now zero, ready for fresh measurements
     */
    clearInstanceCache() {
      logInfo("üßπ Clearing template engine instance cache...");
      this.compiledTemplates.clear();
      performanceMetrics.cacheHits = 0;
      performanceMetrics.cacheMisses = 0;
      performanceMetrics.totalRenderTime = 0;
      performanceMetrics.renderCount = 0;
    }

    /**
     * Clear ALL template caches system-wide - Global cache and performance metrics.
     * Delegates to: GlobalTemplateCache.clearCache() for global cache cleanup
     *
     * ‚ö†Ô∏è WARNING: This is a nuclear option that clears the entire template system:
     * - Empties the GlobalTemplateCache singleton (affects all engine instances)
     * - Resets all performance metrics to zero
     * - Forces template reloading from files on next access
     * - Affects every EnhancedTemplateEngine instance in the application
     *
     * Use this static method only when:
     * - Performing complete system reset during development
     * - Switching between different template sets
     * - Recovering from cache corruption issues
     * - Testing template loading performance from scratch
     *
     * In production, prefer instance-level clearInstanceCache() to avoid
     * affecting other parts of the application.
     *
     * @returns {void}
     * @static
     *
     * @example
     * // Complete system reset during development
     * EnhancedTemplateEngine.clearAllCaches();
     * // All caches cleared, templates will reload on next access
     *
     * @example
     * // Reset before performance testing
     * EnhancedTemplateEngine.clearAllCaches();
     * const engine = new EnhancedTemplateEngine();
     * // Measures true cold-start performance
     */
    static clearAllCaches() {
      logWarn(
        "[TemplateSystem] üßπ Clearing ALL template caches (global + instances)..."
      );
      GlobalTemplateCache.clearCache();
      performanceMetrics.cacheHits = 0;
      performanceMetrics.cacheMisses = 0;
      performanceMetrics.totalRenderTime = 0;
      performanceMetrics.renderCount = 0;
    }

    // ===========================================================================================
    // COMPREHENSIVE TESTING
    // ===========================================================================================

    /**
     * Comprehensive test suite for the Enhanced Template Engine.
     *
     * This 250-line test method validates all core functionality of the template
     * system with 17 distinct test cases covering:
     * - Basic variable substitution and HTML escaping
     * - Control flow (if/else conditionals, each loops)
     * - Advanced features (partials, helpers, filters)
     * - Real-world templates (reading tools, theme toggle, MathJax controls)
     * - Performance validation (caching behaviour)
     * - British spelling helper
     * - Template syntax validation
     *
     * Each test is timed individually and results are aggregated into a
     * comprehensive report. The method returns detailed results including:
     * - Overall success status (all tests must pass)
     * - Individual test results with timings
     * - Performance metrics (cache hit rate, average render time)
     * - Total execution statistics
     *
     * This is the primary validation method for ensuring template system
     * integrity and should be run after any modifications to the template
     * engine or template content.
     *
     * @returns {Object} Test results object
     * @returns {boolean} result.success - True if all tests passed
     * @returns {number} result.passed - Number of tests that passed
     * @returns {number} result.total - Total number of tests run
     * @returns {Array<Object>} result.results - Detailed results for each test
     * @returns {Object} result.performance - Performance metrics report
     *
     * @example
     * const engine = new EnhancedTemplateEngine();
     * const results = engine.test();
     * console.log(`Tests: ${results.passed}/${results.total} passed`);
     * // Console output shows each test result:
     * // ‚úÖ Basic Variable Substitution: PASSED (0.23ms)
     * // ‚úÖ HTML Escaping: PASSED (0.18ms)
     * // ...
     * // üìä Template Engine Tests: 17/17 passed
     * // üìà Performance Report: { averageRenderTime: '2.34ms', ... }
     *
     * @example
     * // Check specific test results
     * const results = engine.test();
     * if (!results.success) {
     *   const failures = results.results.filter(r => !r.passed);
     *   console.error('Failed tests:', failures);
     * }
     */
    test() {
      logInfo("üß™ Testing Enhanced Template Engine...");

      const tests = [
        {
          name: "Basic Variable Substitution",
          test: () => {
            this.templates.set("test-var", "Hello {{name}}!");
            const result = this.render("test-var", { name: "World" });
            return result === "Hello World!";
          },
        },
        {
          name: "HTML Escaping",
          test: () => {
            this.templates.set("test-escape", "Safe: {{html}}");
            const result = this.render("test-escape", {
              html: '<script>alert("xss")</script>',
            });
            return result.includes("&lt;script&gt;");
          },
        },
        {
          name: "Raw HTML Output",
          test: () => {
            this.templates.set("test-raw", "Raw: {{{html}}}");
            const result = this.render("test-raw", {
              html: "<strong>bold</strong>",
            });
            return result === "Raw: <strong>bold</strong>";
          },
        },
        {
          name: "Each Loop",
          test: () => {
            this.templates.set(
              "test-each",
              "{{#each items}}<li>{{this}}</li>{{/each}}"
            );
            const result = this.render("test-each", { items: ["a", "b", "c"] });
            return result === "<li>a</li><li>b</li><li>c</li>";
          },
        },
        {
          name: "Each with Index",
          test: () => {
            this.templates.set(
              "test-index",
              "{{#each items}}{{@index}}: {{this}}, {{/each}}"
            );
            const result = this.render("test-index", { items: ["a", "b"] });
            return result === "0: a, 1: b, ";
          },
        },
        {
          name: "If Conditional",
          test: () => {
            this.templates.set("test-if", "{{#if show}}visible{{/if}}");
            const result1 = this.render("test-if", { show: true });
            const result2 = this.render("test-if", { show: false });
            return result1 === "visible" && result2 === "";
          },
        },
        {
          name: "If/Else Conditional",
          test: () => {
            this.templates.set("test-else", "{{#if show}}yes{{else}}no{{/if}}");
            const result1 = this.render("test-else", { show: true });
            const result2 = this.render("test-else", { show: false });
            return result1 === "yes" && result2 === "no";
          },
        },
        {
          name: "Nested Properties",
          test: () => {
            this.templates.set("test-nested", "Hello {{user.name}}!");
            const result = this.render("test-nested", {
              user: { name: "John" },
            });
            return result === "Hello John!";
          },
        },
        {
          name: "Helpers",
          test: () => {
            this.templates.set(
              "test-helper",
              'Size: {{formatSize value "px"}}'
            );
            const result = this.render("test-helper", { value: 16 });
            logDebug("Helper test result:", result);
            logDebug("Expected: Size: 16px");
            return result === "Size: 16px";
          },
        },
        {
          name: "Filters",
          test: () => {
            this.templates.set("test-filter", "{{name | uppercase}}");
            const result = this.render("test-filter", { name: "test" });
            logDebug("Filter test result:", result);
            logDebug("Expected: TEST");
            return result === "TEST";
          },
        },
        {
          name: "Partials",
          test: () => {
            this.partials.set("greeting", "Hello {{name}}!");
            this.templates.set("test-partial", "Message: {{> greeting}}");
            const result = this.render("test-partial", { name: "World" });
            return result === "Message: Hello World!";
          },
        },
        {
          name: "Reading Tools Template",
          test: () => {
            const html = this.render("readingToolsSection");
            return (
              html.includes("reading-tools-section") &&
              html.includes("Font:") &&
              html.includes("Font size:")
            );
          },
        },
        {
          name: "Theme Toggle Template",
          test: () => {
            const html = this.render("themeToggleSection");
            logDebug("Theme toggle HTML:", html);
            const hasThemeToggle = html.includes("theme-toggle");
            const hasMoon = html.includes("üåô");
            const hasDark = html.includes("Dark");
            logDebug("Theme toggle checks:", {
              hasThemeToggle,
              hasMoon,
              hasDark,
            });
            return hasThemeToggle && hasMoon && hasDark;
          },
        },
        {
          name: "MathJax Controls Template",
          test: () => {
            const html = this.render("mathJaxAccessibilityControls");
            logDebug("MathJax controls HTML length:", html.length);
            const hasMathJax = html.includes("MathJax Accessibility");
            const hasZoomClick = html.includes("zoom-click");
            const hasAssistive = html.includes("assistive-mathml");
            logDebug("MathJax checks:", {
              hasMathJax,
              hasZoomClick,
              hasAssistive,
            });
            return hasMathJax && hasZoomClick && hasAssistive;
          },
        },
        {
          name: "British Spelling Helper",
          test: () => {
            this.templates.set("test-british", "{{britishSpelling text}}");
            const result = this.render("test-british", {
              text: "color customized",
            });
            logDebug("British spelling result:", result);
            logDebug("Expected: colour customised");
            return result === "colour customised";
          },
        },
        {
          name: "Template Validation",
          test: () => {
            this.templates.set("invalid", "{{#if test}}unclosed");
            const validation = this.validateTemplate("invalid");
            return !validation.valid && validation.errors.length > 0;
          },
        },
        {
          name: "Performance Caching",
          test: () => {
            // Reset metrics
            performanceMetrics.cacheHits = 0;
            performanceMetrics.cacheMisses = 0;

            // Clear compiled template cache to ensure fresh test
            this.compiledTemplates.clear();

            // First render should miss cache
            this.render("themeToggleSection");
            const firstMisses = performanceMetrics.cacheMisses;
            logDebug(
              `After first render - misses: ${firstMisses}, hits: ${performanceMetrics.cacheHits}`
            );

            // Second render should hit cache
            this.render("themeToggleSection");
            const cacheHits = performanceMetrics.cacheHits;
            logDebug(
              `After second render - misses: ${performanceMetrics.cacheMisses}, hits: ${cacheHits}`
            );

            return (
              firstMisses >= 1 &&
              cacheHits >= 1 &&
              performanceMetrics.cacheMisses >= performanceMetrics.cacheHits
            );
          },
        },
      ];

      let passed = 0;
      const results = [];

      tests.forEach((test) => {
        try {
          const startTime = window.performance.now();
          const success = test.test();
          const duration = window.performance.now() - startTime;

          if (success) {
            logInfo(`‚úÖ ${test.name}: PASSED (${duration.toFixed(2)}ms)`);
            passed++;
          } else {
            logError(`[TemplateSystem] ‚ùå ${test.name}: FAILED`);
          }

          results.push({ name: test.name, passed: success, duration });
        } catch (error) {
          logError(
            `[TemplateSystem] ‚ùå ${test.name}: ERROR - ${error.message}`
          );
          results.push({
            name: test.name,
            passed: false,
            error: error.message,
          });
        }
      });

      const allPassed = passed === tests.length;
      logInfo(`üìä Template Engine Tests: ${passed}/${tests.length} passed`);

      // Show performance report
      const perfReport = this.getPerformanceReport();
      logInfo("üìà Performance Report:", perfReport);

      return {
        success: allPassed,
        passed,
        total: tests.length,
        results,
        performance: perfReport,
      };
    }
  }

  // ===========================================================================================
  // BACKWARD COMPATIBILITY WRAPPER
  // ===========================================================================================

  /**
   * Legacy EnhancedHTMLGenerator class for backward compatibility.
   *
   * This wrapper class maintains the original EnhancedHTMLGenerator API
   * while delegating all operations to the newer EnhancedTemplateEngine.
   * It exists purely for backward compatibility with code that expects
   * the old class name and method signatures.
   *
   * The class automatically creates an EnhancedTemplateEngine instance
   * during construction and proxies all method calls to it. This allows
   * existing code to continue working without modification while new
   * code can use the more appropriately named EnhancedTemplateEngine.
   *
   * New code should use EnhancedTemplateEngine directly rather than
   * this legacy wrapper. This class may be deprecated in future versions.
   *
   * @class
   * @deprecated Use EnhancedTemplateEngine directly for new code
   */
  class EnhancedHTMLGenerator {
    /**
     * Create a legacy EnhancedHTMLGenerator instance.
     * Delegates to: EnhancedTemplateEngine for all template operations
     *
     * This constructor creates a new EnhancedTemplateEngine instance and
     * stores it in this.engine. All subsequent method calls are proxied
     * to this internal engine instance.
     *
     * @example
     * // Legacy code (still works)
     * const generator = new EnhancedHTMLGenerator();
     * const html = generator.renderTemplate('readingToolsSection');
     *
     * @example
     * // Preferred approach (new code)
     * const engine = new EnhancedTemplateEngine();
     * const html = engine.render('readingToolsSection');
     */
    constructor() {
      this.engine = new EnhancedTemplateEngine();
      logInfo(
        "‚úÖ Enhanced HTML Template System initialised with caching engine"
      );
    }

    /**
     * Render a template with data - Legacy method signature.
     * Delegates to: EnhancedTemplateEngine.render() for actual rendering
     *
     * This method maintains backward compatibility with the original
     * EnhancedHTMLGenerator API by providing the renderTemplate() method
     * name while internally delegating to the engine's render() method.
     *
     * New code should use engine.render() directly instead of this wrapper.
     *
     * @param {string} templateName - Name of template to render
     * @param {Object} data - Data to pass to template (optional)
     * @returns {string} Rendered HTML string
     *
     * @example
     * // Legacy usage
     * const generator = new EnhancedHTMLGenerator();
     * const html = generator.renderTemplate('themeToggleSection', { isDarkMode: true });
     */
    renderTemplate(templateName, data = {}) {
      return this.engine.render(templateName, data); // ‚úÖ FIXED: Use correct method name
    }

    /**
     * Generate font options HTML - Legacy method for backward compatibility.
     * Delegates to: EnhancedTemplateEngine.getDefaultTemplateData() for font data
     *
     * This method generates HTML <option> elements for a font selection dropdown
     * using the default font options from the template system. It manually
     * constructs HTML strings rather than using templates, maintaining the
     * original API behaviour.
     *
     * The method:
     * 1. Fetches default reading tools data (includes 11 font options)
     * 2. Maps each font option to an HTML <option> element
     * 3. Marks the selected option (Verdana by default)
     * 4. Returns newline-separated HTML string
     *
     * New code should use the readingToolsSection template directly instead
     * of manually generating option HTML.
     *
     * @returns {string} HTML string of <option> elements for font selection
     * @deprecated Use readingToolsSection template for new code
     *
     * @example
     * const generator = new EnhancedHTMLGenerator();
     * const options = generator.getFontOptions();
     * // Returns:
     * // <option value="Verdana, sans-serif" selected>Verdana (sans-serif)</option>
     * // <option value="Arial, sans-serif">Arial (sans-serif)</option>
     * // ...
     */
    getFontOptions() {
      const data = this.engine.getDefaultTemplateData("readingToolsSection");
      return data.fontOptions
        .map(
          (opt) =>
            `<option value="${opt.value}"${opt.selected ? " selected" : ""}>${
              opt.label
            }</option>`
        )
        .join("\n");
    }

    /**
     * Generate reading width options HTML - Legacy method for backward compatibility.
     * Delegates to: EnhancedTemplateEngine.getDefaultTemplateData() for width data
     *
     * This method generates HTML <option> elements for a reading width selection
     * dropdown using the default width options from the template system. Like
     * getFontOptions(), it manually constructs HTML strings for backward compatibility.
     *
     * The method:
     * 1. Fetches default reading tools data (includes 4 width options)
     * 2. Maps each width option to an HTML <option> element
     * 3. Marks the selected option (narrow by default)
     * 4. Returns newline-separated HTML string
     *
     * Width options include: full, wide, narrow (default), extra-narrow
     *
     * New code should use the readingToolsSection template directly instead
     * of manually generating option HTML.
     *
     * @returns {string} HTML string of <option> elements for width selection
     * @deprecated Use readingToolsSection template for new code
     *
     * @example
     * const generator = new EnhancedHTMLGenerator();
     * const options = generator.getWidthOptions();
     * // Returns:
     * // <option value="full">Full width</option>
     * // <option value="wide">Wide</option>
     * // <option value="narrow" selected>Narrow</option>
     * // <option value="extra-narrow">Extra narrow</option>
     */
    getWidthOptions() {
      const data = this.engine.getDefaultTemplateData("readingToolsSection");
      return data.widthOptions
        .map(
          (opt) =>
            `<option value="${opt.value}"${opt.selected ? " selected" : ""}>${
              opt.label
            }</option>`
        )
        .join("\n");
    }

    // ===========================================================================================
    // JAVASCRIPT GENERATION METHODS (for export-manager.js integration)
    // ===========================================================================================

    /**
     * Load JavaScript code from external template file in templates/js/ directory.
     * Templates: templates/js/{filename}
     *
     * This is the core loader for all JavaScript template files. It fetches
     * JavaScript code from the templates/js/ directory, applies proper HTML
     * indentation (8 spaces) for embedding in <script> tags, and provides
     * comprehensive error handling.
     *
     * The method automatically:
     * - Fetches from templates/js/{filename} path
     * - Validates HTTP response (throws on 404/500/etc.)
     * - Indents every non-empty line with 8 spaces for HTML embedding
     * - Preserves empty lines for readability
     * - Logs detailed debug information
     * - Throws descriptive errors for fallback handling
     *
     * This loader is used by all generate*JS() methods to load their
     * respective template files. The consistent 8-space indentation ensures
     * properly formatted <script> tags in exported HTML documents.
     *
     * @param {string} filename - JavaScript filename (e.g., 'initialization.js')
     * @returns {Promise<string>} JavaScript content with 8-space indentation
     * @throws {Error} [TemplateSystem] If file not found or fetch fails
     *
     * @example
     * const js = await generator.loadJavaScriptTemplate('theme-management.js');
     * // Returns properly indented JavaScript:
     * //         // Theme management code
     * //         function initializeTheme() {
     * //           ...
     * //         }
     *
     * @example
     * // Error handling
     * try {
     *   const js = await generator.loadJavaScriptTemplate('missing.js');
     * } catch (error) {
     *   console.error('Failed to load:', error.message);
     *   // Error: [TemplateSystem] Failed to load JavaScript template: missing.js (HTTP 404)
     * }
     */
    async loadJavaScriptTemplate(filename) {
      try {
        const response = await fetch(`templates/js/${filename}`);
        if (!response.ok) {
          throw new Error(
            `[TemplateSystem] Failed to load JavaScript template: ${filename} (HTTP ${response.status})`
          );
        }
        const content = await response.text();
        logDebug(
          `‚úÖ Loaded JavaScript template: ${filename} (${content.length} chars)`
        );

        // Add proper indentation for HTML embedding (8 spaces)
        const indentedContent = content
          .split("\n")
          .map((line) => (line.trim() ? "        " + line : line))
          .join("\n");

        return indentedContent;
      } catch (error) {
        logError(
          `[TemplateSystem] ‚ùå Failed to load JavaScript template ${filename}:`,
          error
        );
        throw error; // Re-throw to allow fallback handling
      }
    }

    /**
     * Generate initialization JavaScript for exported HTML documents.
     * Delegates to: loadJavaScriptTemplate() for file loading
     * Templates: templates/js/initialization.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     *
     * This method loads the core initialization script that runs when an
     * exported HTML document loads. The initialization script:
     * - Sets up global accessibility defaults
     * - Initialises reading tools (font, spacing, width controls)
     * - Configures theme management
     * - Enables keyboard navigation
     * - Prepares MathJax accessibility features
     *
     * The script is loaded from an external template file to enable easy
     * maintenance and updates without modifying the template system code.
     * There is NO fallback - the external template MUST be present.
     *
     * @returns {Promise<string>} JavaScript code for document initialization (8-space indented)
     * @throws {Error} [TemplateSystem] If initialization.js template not found
     *
     * @example
     * const js = await generator.generateInitializationJS();
     * // Returns: Complete initialization script with proper indentation
     * // Ready to embed in <script> tag in exported HTML
     *
     * @example
     * // Used by export-manager.js during export
     * const initScript = await templateSystem.generateInitializationJS();
     * const html = `
     *   <script>
     * ${initScript}
     *   </script>
     * `;
     */
    async generateInitializationJS() {
      // Load JavaScript from external template file - NO FALLBACK
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: initialization.js"
        );
        const javascriptContent = await this.loadJavaScriptTemplate(
          "initialization.js"
        );
        logDebug(
          "‚úÖ JavaScript template loaded successfully, using external file"
        );
        return javascriptContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: JavaScript template loading failed - NO FALLBACK AVAILABLE:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }

    /**
     * Generate MathJax accessibility controls JavaScript with configurable features.
     * Delegates to: loadJavaScriptTemplate() for file loading, render() for variable substitution
     * Templates: templates/js/mathjax-controls.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     *
     * This method generates the JavaScript that controls MathJax accessibility
     * features in exported documents. Configuration varies by accessibility level:
     *
     * Level 1 (Basic):
     * - Click-to-zoom equations (200% default scale)
     * - Assistive MathML for screen readers
     *
     * Level 2 (Enhanced):
     * - All Level 1 features
     * - Tab navigation between equations
     * - Equation explorer mode
     *
     * The method loads the template, applies configuration variables using
     * the Handlebars engine, and returns properly indented JavaScript ready
     * for embedding in <script> tags.
     *
     * @param {number} accessibilityLevel - Accessibility feature level (1 = basic, 2 = enhanced, default: 1)
     * @returns {Promise<string>} Configured MathJax controls JavaScript (8-space indented)
     * @throws {Error} [TemplateSystem] If mathjax-controls.js template not found
     *
     * @example
     * // Basic accessibility
     * const js = await generator.generateMathJaxControlsJS(1);
     * // Enables: click-to-zoom, assistive MathML
     *
     * @example
     * // Enhanced accessibility
     * const js = await generator.generateMathJaxControlsJS(2);
     * // Enables: all basic features + tab navigation + equation explorer
     */
    async generateMathJaxControlsJS(accessibilityLevel = 1) {
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: mathjax-controls.js"
        );

        // Load the raw JavaScript template (fix: use this.loadJavaScriptTemplate, not this.engine.loadJavaScriptTemplate)
        const rawJavascriptContent = await this.loadJavaScriptTemplate(
          "mathjax-controls.js"
        );

        // Apply configuration based on accessibility level
        const config = {
          zoom: "Click",
          zscale: "200%",
          assistiveMathML: true,
          tabNavigation: accessibilityLevel >= 2,
          explorerEnabled: accessibilityLevel >= 2,
        };

        // Process template variables using the engine's render method
        // First, create a temporary template name and store the content
        const tempTemplateName = "mathJaxControlsJS_temp";
        this.engine.templates.set(tempTemplateName, rawJavascriptContent);

        // Use the engine's render method to process variables
        const processedContent = this.engine.render(tempTemplateName, config);

        // Clean up temporary template
        this.engine.templates.delete(tempTemplateName);

        logDebug(
          "‚úÖ JavaScript template loaded and processed successfully, using external file"
        );
        return processedContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: JavaScript template loading failed - NO FALLBACK:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }

    /**
     * Generate reading tools setup JavaScript with configurable defaults.
     * Delegates to: loadJavaScriptTemplate() for file loading, render() for variable substitution
     * Templates: templates/js/reading-tools-setup.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     * ‚úÖ FIXED: Uses centralised accessibility defaults from AppConfig
     *
     * This method generates the JavaScript that initialises reading accessibility
     * controls in exported documents. It configures:
     * - Default font family (Verdana by default)
     * - Default font size (1.0 = 100% by default)
     * - Default reading width (narrow by default)
     * - Line height (1.6 by default)
     * - Paragraph spacing (1.0 by default)
     * - Advanced controls visibility (accessibilityLevel >= 2)
     *
     * The method:
     * 1. Loads template from templates/js/reading-tools-setup.js
     * 2. Merges user options with AppConfig defaults
     * 3. Processes template variables using Handlebars
     * 4. Returns properly indented JavaScript
     *
     * Options can override any default value. If not provided, the method
     * uses centralised defaults from window.AppConfig.CONFIG.ACCESSIBILITY_DEFAULTS.
     *
     * @param {number} accessibilityLevel - Feature level (1 = basic, 2 = advanced, default: 1)
     * @param {Object} options - Configuration overrides (all optional)
     * @param {number} [options.defaultFontSize=1.0] - Initial font size multiplier
     * @param {string} [options.defaultFontFamily='Verdana, sans-serif'] - Initial font family
     * @param {string} [options.defaultReadingWidth='narrow'] - Initial content width
     * @param {number} [options.defaultLineHeight=1.6] - Initial line height
     * @param {number} [options.defaultParagraphSpacing=1.0] - Initial paragraph spacing
     * @returns {Promise<string>} Reading tools setup JavaScript (8-space indented)
     * @throws {Error} [TemplateSystem] If reading-tools-setup.js template not found
     *
     * @example
     * // Use all defaults
     * const js = await generator.generateReadingToolsSetupJS();
     * // Font: Verdana, Size: 100%, Width: narrow, Line height: 1.6
     *
     * @example
     * // Custom defaults for large print version
     * const js = await generator.generateReadingToolsSetupJS(1, {
     *   defaultFontSize: 1.4,
     *   defaultLineHeight: 1.8
     * });
     */
    async generateReadingToolsSetupJS(accessibilityLevel = 1, options = {}) {
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: reading-tools-setup.js"
        );

        // Load the raw JavaScript template
        const rawJavascriptContent = await this.loadJavaScriptTemplate(
          "reading-tools-setup.js"
        );

        // ‚úÖ FIXED: Use centralized accessibility defaults with EXACT template variable names
        const defaults = window.AppConfig?.CONFIG?.ACCESSIBILITY_DEFAULTS || {};
        const config = {
          // Template expects these EXACT variable names (without double braces)
          fontSize: options.defaultFontSize || defaults.defaultFontSize || 1.0, // ‚úÖ Number, not string
          fontFamily:
            options.defaultFontFamily ||
            defaults.defaultFontFamily ||
            "Verdana, sans-serif",
          readingWidth:
            options.defaultReadingWidth ||
            defaults.defaultReadingWidth ||
            "narrow",
          lineHeight:
            options.defaultLineHeight || defaults.defaultLineHeight || 1.6, // ‚úÖ Number, not string
          paragraphSpacing:
            options.defaultParagraphSpacing ||
            defaults.defaultParagraphSpacing ||
            1.0, // ‚úÖ Number, not string
          advancedControls: accessibilityLevel >= 2,
        };
        // Process template variables using the engine's render method
        const tempTemplateName = "readingToolsSetupJS_temp";
        this.engine.templates.set(tempTemplateName, rawJavascriptContent);

        // Use the engine's render method to process variables
        const processedContent = this.engine.render(tempTemplateName, config);

        // Clean up temporary template
        this.engine.templates.delete(tempTemplateName);

        logDebug(
          "‚úÖ Reading Tools Setup JavaScript template loaded and processed successfully with proper variable replacement"
        );
        return processedContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: Reading Tools Setup JavaScript template loading failed - NO FALLBACK:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }

    /**
     * Generate theme management JavaScript for light/dark mode switching.
     * Delegates to: loadJavaScriptTemplate() for file loading, render() for variable substitution
     * Templates: templates/js/theme-management.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     *
     * This method generates the JavaScript that handles theme switching in
     * exported documents. Features include:
     * - Light/dark mode toggle
     * - System preference detection and respect
     * - localStorage persistence (remembers user choice)
     * - Smooth transitions (optional)
     * - WCAG 2.2 AA compliant colour contrast in both modes
     * - Accessible theme toggle button with proper ARIA labels
     *
     * Configuration options:
     * - defaultTheme: Initial theme ('light' or 'dark')
     * - enableTransitions: Smooth transitions between themes
     * - respectSystemPreference: Auto-detect OS preference on first visit
     *
     * The script automatically:
     * - Detects system dark mode preference (prefers-color-scheme)
     * - Applies theme immediately on page load (prevents flash)
     * - Updates button text and ARIA labels
     * - Saves preference to localStorage
     *
     * @param {Object} options - Theme configuration (all optional)
     * @param {string} [options.defaultTheme='light'] - Initial theme ('light' or 'dark')
     * @param {boolean} [options.enableTransitions=true] - Enable smooth transitions
     * @param {boolean} [options.respectSystemPreference=true] - Auto-detect OS preference
     * @returns {Promise<string>} Theme management JavaScript (8-space indented)
     * @throws {Error} [TemplateSystem] If theme-management.js template not found
     *
     * @example
     * // Use defaults (light theme, system detection enabled)
     * const js = await generator.generateThemeManagementJS();
     *
     * @example
     * // Force dark theme by default, no system detection
     * const js = await generator.generateThemeManagementJS({
     *   defaultTheme: 'dark',
     *   respectSystemPreference: false
     * });
     */
    async generateThemeManagementJS(options = {}) {
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: theme-management.js"
        );

        // Load the raw JavaScript template
        const rawJavascriptContent = await this.loadJavaScriptTemplate(
          "theme-management.js"
        );

        // Apply configuration based on options
        const config = {
          defaultTheme: options.defaultTheme || "light",
          enableTransitions: options.enableTransitions !== false,
          respectSystemPreference: options.respectSystemPreference !== false,
        };

        // Process template variables using the engine's render method
        const tempTemplateName = "themeManagementJS_temp";
        this.engine.templates.set(tempTemplateName, rawJavascriptContent);

        // Use the engine's render method to process variables
        const processedContent = this.engine.render(tempTemplateName, config);

        // Clean up temporary template
        this.engine.templates.delete(tempTemplateName);

        logDebug(
          "‚úÖ Theme Management JavaScript template loaded and processed successfully, using external file"
        );
        return processedContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: Theme Management JavaScript template loading failed - NO FALLBACK:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }

    /**
     * Generate form initialisation JavaScript for accessibility controls.
     * Delegates to: loadJavaScriptTemplate() for file loading, render() for variable substitution
     * Templates: templates/js/form-initialization.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     * ‚úÖ FIXED: Uses centralised accessibility defaults from AppConfig
     *
     * This method generates the JavaScript that initialises all form controls
     * in the exported document's accessibility sidebar. It sets up:
     * - Font selection dropdown (default: Verdana)
     * - Font size slider (default: 100%)
     * - Reading width radio buttons (default: narrow)
     * - Line height controls (default: 1.6)
     * - Word spacing controls (default: 0)
     * - Zoom level controls (default: 100%)
     * - Form validation (optional)
     * - Accessibility enhancements (optional)
     * - User preference persistence (optional)
     *
     * The script ensures all form controls reflect their default values on
     * page load and are properly connected to their change handlers. It uses
     * centralised defaults from AppConfig when available, with sensible
     * fallbacks for each control.
     *
     * @param {Object} options - Form configuration overrides (all optional)
     * @param {string} [options.defaultFontSize='1.0'] - Initial font size multiplier
     * @param {string} [options.defaultFontSizePercent='100%'] - Font size as percentage
     * @param {string} [options.defaultLineHeight='1.6'] - Initial line height
     * @param {string} [options.defaultWordSpacing='0'] - Initial word spacing
     * @param {string} [options.defaultReadingWidth='narrow'] - Initial reading width
     * @param {string} [options.defaultZoomLevel='1.0'] - Initial zoom level
     * @param {boolean} [options.enableValidation=true] - Enable form validation
     * @param {boolean} [options.enableAccessibility=true] - Enable accessibility features
     * @param {boolean} [options.enablePreferences=true] - Enable preference persistence
     * @returns {Promise<string>} Form initialisation JavaScript (8-space indented)
     * @throws {Error} [TemplateSystem] If form-initialization.js template not found
     *
     * @example
     * // Use all defaults
     * const js = await generator.generateFormInitializationJS();
     *
     * @example
     * // Custom defaults for specific audience
     * const js = await generator.generateFormInitializationJS({
     *   defaultFontSize: '1.2',
     *   defaultLineHeight: '1.8',
     *   defaultReadingWidth: 'extra-narrow'
     * });
     */
    async generateFormInitializationJS(options = {}) {
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: form-initialization.js"
        );

        // Load the raw JavaScript template
        const rawJavascriptContent = await this.loadJavaScriptTemplate(
          "form-initialization.js"
        );

        // ‚úÖ FIXED: Use centralized accessibility defaults
        const defaults = window.AppConfig?.CONFIG?.ACCESSIBILITY_DEFAULTS || {};
        const config = {
          defaultFontSize:
            options.defaultFontSize || defaults.defaultFontSize || "1.0",
          defaultFontSizePercent:
            options.defaultFontSizePercent ||
            defaults.defaultFontSizePercent ||
            "100%",
          defaultLineHeight:
            options.defaultLineHeight || defaults.defaultLineHeight || "1.6",
          defaultWordSpacing:
            options.defaultWordSpacing || defaults.defaultWordSpacing || "0",
          defaultReadingWidth:
            options.defaultReadingWidth ||
            defaults.defaultReadingWidth ||
            "narrow", // ‚úÖ FIXED
          defaultZoomLevel:
            options.defaultZoomLevel || defaults.defaultZoomLevel || "1.0",
          enableValidation: options.enableValidation !== false,
          enableAccessibility: options.enableAccessibility !== false,
          enablePreferences: options.enablePreferences !== false,
        };
        // Process template variables using the engine's render method
        const tempTemplateName = "formInitializationJS_temp";
        this.engine.templates.set(tempTemplateName, rawJavascriptContent);

        // Use the engine's render method to process variables
        const processedContent = this.engine.render(tempTemplateName, config);

        // Clean up temporary template
        this.engine.templates.delete(tempTemplateName);

        logDebug(
          "‚úÖ Form Initialization JavaScript template loaded and processed successfully, using external file"
        );
        return processedContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: Form Initialization JavaScript template loading failed - NO FALLBACK:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }

    /**
     * Generate focus tracking JavaScript for keyboard navigation and accessibility.
     * Delegates to: loadJavaScriptTemplate() for file loading, render() for variable substitution
     * Templates: templates/js/focus-tracking.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     *
     * This method generates the JavaScript that implements comprehensive keyboard
     * navigation and focus management in exported documents. Features include:
     * - Visual focus indicators (WCAG 2.2 AA compliant)
     * - Focus history tracking (back/forward navigation)
     * - Keyboard shortcuts for common actions
     * - Screen reader announcements for focus changes
     * - Skip link support (skip to main content)
     * - Console commands for debugging focus issues
     *
     * Configuration options control which features are enabled. All features
     * default to enabled (true) for maximum accessibility. The focus tracking
     * system is particularly important for users who rely on keyboard navigation
     * or screen readers.
     *
     * Console commands (when enabled):
     * - getFocusHistory(): Show recent focus changes
     * - getCurrentFocus(): Get currently focused element
     * - clearFocusHistory(): Reset focus tracking
     *
     * @param {Object} options - Focus tracking configuration (all optional)
     * @param {boolean} [options.enableFocusTracking=true] - Track focus changes
     * @param {boolean} [options.enableKeyboardNavigation=true] - Enable keyboard shortcuts
     * @param {boolean} [options.enableAccessibilityAnnouncements=true] - Screen reader announcements
     * @param {boolean} [options.enableFocusHistory=true] - Track focus history
     * @param {boolean} [options.enableConsoleCommands=true] - Enable debug commands
     * @param {number} [options.commandsDelayMs=100] - Delay before enabling commands (ms)
     * @returns {Promise<string>} Focus tracking JavaScript (8-space indented)
     * @throws {Error} [TemplateSystem] If focus-tracking.js template not found
     *
     * @example
     * // Enable all features (default)
     * const js = await generator.generateFocusTrackingJS();
     *
     * @example
     * // Minimal setup (tracking only, no console commands)
     * const js = await generator.generateFocusTrackingJS({
     *   enableConsoleCommands: false,
     *   enableFocusHistory: false
     * });
     */
    async generateFocusTrackingJS(options = {}) {
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: focus-tracking.js"
        );

        const rawJavascriptContent = await this.loadJavaScriptTemplate(
          "focus-tracking.js"
        );

        const config = {
          enableFocusTracking: options.enableFocusTracking !== false,
          enableKeyboardNavigation: options.enableKeyboardNavigation !== false,
          enableAccessibilityAnnouncements:
            options.enableAccessibilityAnnouncements !== false,
          enableFocusHistory: options.enableFocusHistory !== false,
          enableConsoleCommands: options.enableConsoleCommands !== false,
          commandsDelayMs: options.commandsDelayMs || 100,
        };

        // Process template variables using the engine's render method
        const tempTemplateName = "focusTrackingJS_temp";
        this.engine.templates.set(tempTemplateName, rawJavascriptContent);

        // Use the engine's render method to process variables
        const processedContent = this.engine.render(tempTemplateName, config);

        // Clean up temporary template
        this.engine.templates.delete(tempTemplateName);

        logDebug(
          "‚úÖ Focus Tracking JavaScript template loaded and processed successfully, using external file"
        );
        return processedContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: Focus Tracking JavaScript template loading failed - NO FALLBACK:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }

    /**
     * Generate CSS with embedded font data for offline accessibility fonts.
     * Delegates to: loadFontData() for font file loading, render() for CSS generation
     * Templates: templates/embedded-fonts.html
     *
     * This critical method embeds font files directly into CSS using base64
     * data URIs, ensuring exported documents work offline without external
     * font dependencies. Embedded fonts include:
     * - OpenDyslexic (4 variants: regular, bold, italic, bold-italic)
     * - Annotation Mono (variable font with weight range 100-1000)
     *
     * The method:
     * 1. Loads font data from external .txt files (base64 encoded)
     * 2. Maps font data to template variables
     * 3. Renders embedded-fonts template with @font-face declarations
     * 4. Returns CSS ready for embedding in <style> tags
     * 5. Gracefully degrades if fonts unavailable (returns empty string)
     *
     * Font data is loaded from:
     * - fonts/opendyslexic-regular.txt
     * - fonts/opendyslexic-bold.txt
     * - fonts/opendyslexic-italic.txt
     * - fonts/opendyslexic-bold-italic.txt
     * - fonts/AnnotationMono-VF.txt
     *
     * The generated CSS includes proper @font-face declarations with unicode
     * ranges and font-display settings for optimal loading performance.
     *
     * @param {Object} fontData - Optional font data override for testing (keys: regular, bold, italic, boldItalic, AnnotationMonoVF)
     * @returns {Promise<string>} CSS with embedded @font-face declarations or empty string on failure
     *
     * @example
     * // Load all fonts from external files
     * const css = await generator.generateEmbeddedFontsCSS();
     * // Returns: CSS with 5 @font-face declarations (~400-600KB base64 data)
     *
     * @example
     * // Override with custom font data (testing)
     * const css = await generator.generateEmbeddedFontsCSS({
     *   regular: 'CUSTOM_BASE64_DATA',
     *   bold: 'CUSTOM_BASE64_DATA'
     * });
     *
     * @example
     * // Graceful degradation when fonts unavailable
     * const css = await generator.generateEmbeddedFontsCSS();
     * // Returns: '' (empty string, no console errors)
     */
    async generateEmbeddedFontsCSS(fontData = {}) {
      const LOG_LEVELS = {
        ERROR: 0,
        WARN: 1,
        INFO: 2,
        DEBUG: 3,
      };

      const DEFAULT_LOG_LEVEL = LOG_LEVELS.WARN;
      const ENABLE_ALL_LOGGING = false;
      const DISABLE_ALL_LOGGING = false;

      function shouldLog(level) {
        if (DISABLE_ALL_LOGGING) return false;
        if (ENABLE_ALL_LOGGING) return true;
        return level <= DEFAULT_LOG_LEVEL;
      }

      function logError(message, ...args) {
        if (shouldLog(LOG_LEVELS.ERROR)) console.error(message, ...args);
      }

      function logWarn(message, ...args) {
        if (shouldLog(LOG_LEVELS.WARN)) console.warn(message, ...args);
      }

      function logInfo(message, ...args) {
        if (shouldLog(LOG_LEVELS.INFO)) console.log(message, ...args);
      }

      function logDebug(message, ...args) {
        if (shouldLog(LOG_LEVELS.DEBUG)) console.log(message, ...args);
      }

      try {
        logDebug("üîÑ Loading embedded fonts template");

        // Check if template is available
        if (!this.engine.templates.has("embedded-fonts")) {
          logWarn(
            "[TemplateSystem] ‚ö†Ô∏è Embedded fonts template not found - graceful degradation"
          );
          return "";
        }

        // Load font data from external files or use provided data
        const resolvedFontData = await this.loadFontData(fontData);

        // ‚úÖ Map AnnotationMonoVF data to template variables
        const templateData = {
          // OpenDyslexic (existing static font - direct mapping)
          base64Regular: resolvedFontData.base64Regular,
          base64Bold: resolvedFontData.base64Bold,
          base64Italic: resolvedFontData.base64Italic,
          base64BoldItalic: resolvedFontData.base64BoldItalic,

          // ‚úÖ AnnotationMonoVF variable font mapping
          fontNameVariableBase64: resolvedFontData.base64AnnotationMonoVF,

          // ‚úÖ Conditional flag for template
          hasFontNameVariable:
            !!resolvedFontData.base64AnnotationMonoVF &&
            resolvedFontData.base64AnnotationMonoVF !==
              "YOUR_BASE64_PLACEHOLDER",
        };

        logDebug("üé® Template data prepared:", {
          staticFonts: 4,
          variableFonts: templateData.hasFontNameVariable ? 1 : 0,
          annotationMonoVFLength: templateData.fontNameVariableBase64
            ? templateData.fontNameVariableBase64.length
            : 0,
        });

        // Render template with mapped data
        const css = this.engine.render("embedded-fonts", templateData);

        logDebug("‚úÖ Embedded fonts CSS generated successfully");
        logInfo(
          `üéØ Font CSS includes Annotation Mono: ${css.includes(
            "Annotation Mono"
          )}`
        );

        return css;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå Failed to generate embedded fonts CSS:",
          error.message
        );
        // Return empty string if fonts fail to load (graceful degradation)
        return "";
      }
    }

    /**
     * Load accessibility font data from external base64-encoded files.
     * Delegates to: fetch() for file loading
     *
     * This method loads base64-encoded font data from external .txt files in
     * the fonts/ directory. It handles both OpenDyslexic (4 variants) and
     * Annotation Mono (variable font) with comprehensive error handling and
     * fallback behaviour.
     *
     * Font files loaded:
     * - fonts/opendyslexic-regular.txt ‚Üí base64Regular
     * - fonts/opendyslexic-bold.txt ‚Üí base64Bold
     * - fonts/opendyslexic-italic.txt ‚Üí base64Italic
     * - fonts/opendyslexic-bold-italic.txt ‚Üí base64BoldItalic
     * - fonts/AnnotationMono-VF.txt ‚Üí base64AnnotationMonoVF
     *
     * The method:
     * 1. Checks for override data first (useful for testing)
     * 2. Fetches each font file via HTTP
     * 3. Trims whitespace from base64 data
     * 4. Falls back to placeholder on fetch failure
     * 5. Logs detailed progress and errors
     * 6. Returns object with consistently named properties
     *
     * Error handling is graceful - individual font failures don't prevent
     * the method from completing. Failed fonts get placeholder values and
     * a warning is logged.
     *
     * @param {Object} overrideFontData - Optional font data to bypass file loading (for testing)
     * @param {string} [overrideFontData.regular] - Override OpenDyslexic regular
     * @param {string} [overrideFontData.bold] - Override OpenDyslexic bold
     * @param {string} [overrideFontData.italic] - Override OpenDyslexic italic
     * @param {string} [overrideFontData.boldItalic] - Override OpenDyslexic bold-italic
     * @param {string} [overrideFontData.AnnotationMonoVF] - Override Annotation Mono variable font
     * @returns {Promise<Object>} Font data object with base64 strings
     * @returns {string} result.base64Regular - OpenDyslexic regular variant
     * @returns {string} result.base64Bold - OpenDyslexic bold variant
     * @returns {string} result.base64Italic - OpenDyslexic italic variant
     * @returns {string} result.base64BoldItalic - OpenDyslexic bold-italic variant
     * @returns {string} result.base64AnnotationMonoVF - Annotation Mono variable font
     *
     * @example
     * // Load all fonts from external files
     * const fonts = await generator.loadFontData();
     * // Returns: {
     * //   base64Regular: 'AAEAAAALAIAAAwAwT1...',
     * //   base64Bold: 'AAEAAAALAIAAAwAwT1...',
     * //   base64Italic: 'AAEAAAALAIAAAwAwT1...',
     * //   base64BoldItalic: 'AAEAAAALAIAAAwAwT1...',
     * //   base64AnnotationMonoVF: 'AAEAAAALAIAAAwAwT1...'
     * // }
     *
     * @example
     * // Override specific font for testing
     * const fonts = await generator.loadFontData({
     *   regular: 'TEST_BASE64_DATA'
     * });
     * // Loads other fonts from files, uses TEST_BASE64_DATA for regular
     */
    async loadFontData(overrideFontData = {}) {
      const LOG_LEVELS = {
        ERROR: 0,
        WARN: 1,
        INFO: 2,
        DEBUG: 3,
      };

      const DEFAULT_LOG_LEVEL = LOG_LEVELS.WARN;
      const ENABLE_ALL_LOGGING = false;
      const DISABLE_ALL_LOGGING = false;

      function shouldLog(level) {
        if (DISABLE_ALL_LOGGING) return false;
        if (ENABLE_ALL_LOGGING) return true;
        return level <= DEFAULT_LOG_LEVEL;
      }

      function logError(message, ...args) {
        if (shouldLog(LOG_LEVELS.ERROR)) console.error(message, ...args);
      }

      function logWarn(message, ...args) {
        if (shouldLog(LOG_LEVELS.WARN)) console.warn(message, ...args);
      }

      function logInfo(message, ...args) {
        if (shouldLog(LOG_LEVELS.INFO)) console.log(message, ...args);
      }

      function logDebug(message, ...args) {
        if (shouldLog(LOG_LEVELS.DEBUG)) console.log(message, ...args);
      }

      // Font file mapping
      const fontFiles = {
        regular: "fonts/opendyslexic-regular.txt",
        bold: "fonts/opendyslexic-bold.txt",
        italic: "fonts/opendyslexic-italic.txt",
        boldItalic: "fonts/opendyslexic-bold-italic.txt",
        AnnotationMonoVF: "fonts/AnnotationMono-VF.txt",
      };

      const fontData = {};

      // Load each font file
      for (const [variant, filepath] of Object.entries(fontFiles)) {
        try {
          // Use override data if provided
          if (overrideFontData[variant]) {
            fontData[
              `base64${variant.charAt(0).toUpperCase() + variant.slice(1)}`
            ] = overrideFontData[variant];
            logDebug(`‚úÖ Using provided font data for ${variant}`);
            continue;
          }

          // Load from external file
          logDebug(`üîÑ Loading font file: ${filepath}`);
          const response = await fetch(filepath);

          if (!response.ok) {
            throw new Error(
              `[TemplateSystem] HTTP ${response.status}: ${response.statusText}`
            );
          }

          const base64Data = (await response.text()).trim();
          fontData[
            `base64${variant.charAt(0).toUpperCase() + variant.slice(1)}`
          ] = base64Data;

          logDebug(`‚úÖ Loaded ${variant} font (${base64Data.length} chars)`);
        } catch (error) {
          logWarn(
            `[TemplateSystem] ‚ö†Ô∏è Failed to load ${variant} font from ${filepath}:`,
            error.message
          );
          // Fallback to placeholder
          fontData[
            `base64${variant.charAt(0).toUpperCase() + variant.slice(1)}`
          ] = "YOUR_BASE64_PLACEHOLDER";
        }
      }

      logInfo(
        `üé® Font data loading complete: ${
          Object.keys(fontData).length
        }/4 variants loaded`
      );
      return fontData;
    }

    /**
     * Generate ReadingAccessibilityManager class JavaScript for centralised control management.
     * Delegates to: loadJavaScriptTemplate() for file loading, render() for variable substitution
     * Templates: templates/js/reading-accessibility-manager-class.js
     *
     * ‚úÖ MIGRATED: Now uses external JavaScript template file (NO FALLBACK)
     * ‚úÖ FIXED: Uses centralised accessibility defaults from AppConfig
     *
     * This method generates a comprehensive JavaScript class that manages all
     * reading accessibility controls in exported documents. The class provides:
     * - Centralised state management for all accessibility settings
     * - Coordinated updates across multiple UI controls
     * - localStorage persistence for user preferences
     * - Event handling for control interactions
     * - Validation and sanitisation of user inputs
     * - Accessibility announcements for screen readers
     * - Advanced control features (level >= 2)
     *
     * The ReadingAccessibilityManager class acts as the single source of truth
     * for accessibility settings, ensuring consistency between:
     * - Form controls (sliders, dropdowns, radio buttons)
     * - Document styling (CSS custom properties)
     * - User preferences (localStorage)
     * - Screen reader announcements (ARIA live regions)
     *
     * Default values are sourced from:
     * 1. Provided options parameter
     * 2. AppConfig.CONFIG.ACCESSIBILITY_DEFAULTS
     * 3. Hard-coded fallbacks (matching template defaults)
     *
     * @param {Object} options - Manager configuration overrides (all optional)
     * @param {string} [options.defaultFontSize='1.0'] - Initial font size multiplier
     * @param {string} [options.defaultFontFamily='Verdana, sans-serif'] - Initial font family
     * @param {string} [options.defaultReadingWidth='narrow'] - Initial reading width
     * @param {string} [options.defaultLineHeight='1.6'] - Initial line height
     * @param {string} [options.defaultParagraphSpacing='1.0'] - Initial paragraph spacing
     * @param {boolean} [options.enableAdvancedControls=false] - Enable word/letter spacing
     * @returns {Promise<string>} ReadingAccessibilityManager class JavaScript (8-space indented)
     * @throws {Error} [TemplateSystem] If reading-accessibility-manager-class.js template not found
     *
     * @example
     * // Use all defaults
     * const js = await generator.generateReadingAccessibilityManagerClassJS();
     * // Creates class with standard defaults: Verdana, 100%, narrow, 1.6, etc.
     *
     * @example
     * // Custom defaults with advanced controls
     * const js = await generator.generateReadingAccessibilityManagerClassJS({
     *   defaultFontSize: '1.2',
     *   defaultLineHeight: '1.8',
     *   enableAdvancedControls: true
     * });
     * // Enables word spacing and letter spacing controls
     */
    async generateReadingAccessibilityManagerClassJS(options = {}) {
      try {
        logDebug(
          "üîÑ Loading JavaScript from external template: reading-accessibility-manager-class.js"
        );

        // Load the raw JavaScript template
        const rawJavascriptContent = await this.loadJavaScriptTemplate(
          "reading-accessibility-manager-class.js"
        );

        // ‚úÖ FIXED: Use centralized accessibility defaults
        const defaults = window.AppConfig?.CONFIG?.ACCESSIBILITY_DEFAULTS || {};
        const config = {
          defaultFontSize:
            options.defaultFontSize || defaults.defaultFontSize || "1.0",
          defaultFontFamily:
            options.defaultFontFamily ||
            defaults.defaultFontFamily ||
            "Verdana, sans-serif",
          defaultReadingWidth:
            options.defaultReadingWidth ||
            defaults.defaultReadingWidth ||
            "narrow", // ‚úÖ FIXED
          defaultLineHeight:
            options.defaultLineHeight || defaults.defaultLineHeight || "1.6",
          defaultParagraphSpacing:
            options.defaultParagraphSpacing ||
            defaults.defaultParagraphSpacing ||
            "1.0",
          enableAdvancedControls: options.enableAdvancedControls !== false,
        };

        // Process template variables using the engine's render method
        const tempTemplateName = "readingAccessibilityManagerClassJS_temp";
        this.engine.templates.set(tempTemplateName, rawJavascriptContent);

        // Use the engine's render method to process variables
        const processedContent = this.engine.render(tempTemplateName, config);

        // Clean up temporary template
        this.engine.templates.delete(tempTemplateName);

        logDebug(
          "‚úÖ Reading Accessibility Manager Class JavaScript template loaded and processed successfully, using external file"
        );
        return processedContent;
      } catch (error) {
        logError(
          "[TemplateSystem] ‚ùå CRITICAL: Reading Accessibility Manager Class JavaScript template loading failed - NO FALLBACK:",
          error.message
        );
        throw new Error(
          `[TemplateSystem] External template required: ${error.message}`
        );
      }
    }
  }

  // ===========================================================================================
  // PUBLIC API
  // ===========================================================================================

  return {
    // ===========================================================================================
    // CLASS EXPORTS
    // ===========================================================================================
    // Main template engine classes for direct instantiation
    EnhancedHTMLGenerator,
    EnhancedTemplateEngine,

    // ===========================================================================================
    // FACTORY FUNCTIONS
    // ===========================================================================================
    // Create new engine instances with simplified API
    /**
     * Create a new EnhancedHTMLGenerator instance - Factory function for legacy compatibility.
     *
     * This factory function provides a convenient way to create EnhancedHTMLGenerator
     * instances without using the `new` keyword. The generator automatically initialises
     * with a new EnhancedTemplateEngine and loads templates from the global cache.
     *
     * Note: EnhancedHTMLGenerator is a legacy wrapper around EnhancedTemplateEngine.
     * New code should use createEngine() or instantiate EnhancedTemplateEngine directly.
     *
     * @returns {EnhancedHTMLGenerator} New generator instance with template engine
     *
     * @example
     * const generator = TemplateSystem.createGenerator();
     * const html = generator.renderTemplate('readingToolsSection');
     *
     * @example
     * // Preferred approach for new code
     * const engine = TemplateSystem.createEngine();
     * const html = engine.render('readingToolsSection');
     */
    createGenerator() {
      return new EnhancedHTMLGenerator();
    },

    /**
     * Create a new EnhancedTemplateEngine instance - Recommended factory function.
     *
     * This is the recommended way to create template engine instances. The factory
     * function creates a new EnhancedTemplateEngine that automatically:
     * - Initialises with templates from the GlobalTemplateCache singleton
     * - Sets up performance monitoring
     * - Configures Handlebars helpers and filters
     * - Registers default partials
     * - Enables British spelling corrections
     *
     * Each engine instance maintains its own compiled template cache while sharing
     * raw template content via the global cache (singleton pattern for efficiency).
     *
     * @returns {EnhancedTemplateEngine} New template engine instance ready for use
     *
     * @example
     * const engine = TemplateSystem.createEngine();
     * const html = engine.render('readingToolsSection', { fontSize: 1.2 });
     *
     * @example
     * // Multiple independent instances (each with own compiled cache)
     * const engine1 = TemplateSystem.createEngine();
     * const engine2 = TemplateSystem.createEngine();
     * // Both share raw templates but have separate compiled caches
     */
    createEngine() {
      return new EnhancedTemplateEngine();
    },

    // ===========================================================================================
    // TEMPLATE LOADING & CACHE MANAGEMENT
    // ===========================================================================================
    // Load and manage templates from external files or global cache

    // Direct access to global template cache singleton
    GlobalTemplateCache: GlobalTemplateCache,

    // Convenience method to ensure templates are loaded

    /**
     * Ensure all templates are loaded from external files into global cache.
     * Delegates to: GlobalTemplateCache.ensureTemplatesLoaded()
     *
     * This method guarantees that all external template files have been loaded
     * and cached. It uses a singleton pattern - templates are only loaded once
     * even if called multiple times (subsequent calls return immediately).
     *
     * The method:
     * - Returns immediately if templates already loaded
     * - Prevents duplicate loading via promise coordination
     * - Loads all templates from /templates directory
     * - Loads JavaScript templates from /templates/js directory
     * - Returns detailed results with success/failure breakdown
     *
     * This is typically called automatically during engine initialisation, but
     * can be called explicitly to ensure templates are available before use.
     *
     * @returns {Promise<Object>} Load results object
     * @returns {Array<string>} result.loaded - Successfully loaded template names
     * @returns {Array<Object>} result.failed - Failed loads with file and error
     * @returns {boolean} result.success - True if all templates loaded successfully
     *
     * @example
     * // Ensure templates loaded before creating engine
     * await TemplateSystem.ensureTemplatesLoaded();
     * const engine = TemplateSystem.createEngine();
     * // Templates guaranteed to be available
     *
     * @example
     * // Check load results
     * const results = await TemplateSystem.ensureTemplatesLoaded();
     * console.log(`Loaded: ${results.loaded.length} templates`);
     * if (results.failed.length > 0) {
     *   console.warn('Failed:', results.failed);
     * }
     */
    async ensureTemplatesLoaded() {
      return await GlobalTemplateCache.ensureTemplatesLoaded();
    },

    // Get current global cache status

    /**
     * Get current status of the global template cache.
     * Delegates to: GlobalTemplateCache properties
     *
     * This diagnostic method returns comprehensive information about the global
     * template cache state. Useful for:
     * - Debugging template loading issues
     * - Verifying templates are available before rendering
     * - Monitoring cache performance
     * - Development and testing
     *
     * The returned status includes:
     * - Whether templates have been loaded
     * - Whether loading was attempted (even if failed)
     * - Count of templates in cache
     * - List of all template names
     * - Whether loading is currently in progress
     *
     * @returns {Object} Cache status object
     * @returns {boolean} result.isLoaded - True if templates successfully loaded
     * @returns {boolean} result.loadAttempted - True if loading was attempted
     * @returns {number} result.templatesCount - Number of templates in cache
     * @returns {Array<string>} result.templateNames - Array of all template names
     * @returns {boolean} result.loadingInProgress - True if currently loading
     *
     * @example
     * const status = TemplateSystem.getGlobalCacheStatus();
     * console.log(`Templates loaded: ${status.isLoaded}`);
     * console.log(`Template count: ${status.templatesCount}`);
     * console.log(`Available templates:`, status.templateNames);
     *
     * @example
     * // Wait for loading to complete
     * const status = TemplateSystem.getGlobalCacheStatus();
     * if (status.loadingInProgress) {
     *   console.log('Templates currently loading...');
     *   await TemplateSystem.ensureTemplatesLoaded();
     * }
     */
    getGlobalCacheStatus() {
      return {
        isLoaded: GlobalTemplateCache.isLoaded,
        loadAttempted: GlobalTemplateCache.loadAttempted,
        templatesCount: GlobalTemplateCache.templates.size,
        templateNames: Array.from(GlobalTemplateCache.templates.keys()),
        loadingInProgress: GlobalTemplateCache.loadingPromise !== null,
      };
    },

    // Force global cache reload

    /**
     * Force reload of global template cache from external files.
     * Delegates to: GlobalTemplateCache.clearCache() and ensureTemplatesLoaded()
     *
     * This method completely clears the global template cache and reloads all
     * templates from external files. Use cases include:
     * - Template files have been modified during development
     * - Recovering from cache corruption
     * - Switching between different template sets
     * - Testing template loading performance
     *
     * ‚ö†Ô∏è WARNING: This affects ALL template engine instances system-wide since
     * the global cache is a singleton. All engines will need to recompile their
     * templates on next render after a cache reload.
     *
     * @returns {Promise<Object>} Fresh load results from ensureTemplatesLoaded()
     * @returns {Array<string>} result.loaded - Reloaded template names
     * @returns {Array<Object>} result.failed - Any templates that failed to reload
     *
     * @example
     * // Reload after modifying template files
     * await TemplateSystem.reloadGlobalCache();
     * console.log('Templates reloaded from disk');
     *
     * @example
     * // Check reload results
     * const results = await TemplateSystem.reloadGlobalCache();
     * console.log(`Reloaded: ${results.loaded.length} templates`);
     * if (results.failed.length > 0) {
     *   console.error('Failed to reload:', results.failed);
     * }
     */
    async reloadGlobalCache() {
      GlobalTemplateCache.clearCache();
      return await GlobalTemplateCache.ensureTemplatesLoaded();
    },

    // Clear all template caches (global and instance)

    /**
     * Clear all template caches system-wide - Nuclear option.
     * Delegates to: EnhancedTemplateEngine.clearAllCaches()
     *
     * ‚ö†Ô∏è WARNING: This is the most aggressive cache clearing operation. It:
     * - Empties the GlobalTemplateCache singleton (affects all instances)
     * - Resets all performance metrics to zero
     * - Forces template reloading from files on next access
     * - Affects every EnhancedTemplateEngine instance in the application
     * - Clears all compiled template caches
     *
     * Use this method only for:
     * - Complete system reset during development
     * - Recovering from critical cache issues
     * - Performance testing from cold start
     * - Switching between completely different template sets
     *
     * In most cases, prefer reloadGlobalCache() for template updates or
     * engine.clearInstanceCache() for instance-level cleanup.
     *
     * @returns {void}
     *
     * @example
     * // Complete system reset
     * TemplateSystem.clearAllCaches();
     * console.log('All caches cleared - cold start on next use');
     *
     * @example
     * // Reset before performance benchmark
     * TemplateSystem.clearAllCaches();
     * const startTime = performance.now();
     * await TemplateSystem.ensureTemplatesLoaded();
     * const loadTime = performance.now() - startTime;
     * console.log(`Cold load time: ${loadTime}ms`);
     */
    clearAllCaches() {
      EnhancedTemplateEngine.clearAllCaches();
    },

    // ===========================================================================================
    // TEMPLATE RENDERING
    // ===========================================================================================
    // Render templates with data

    // Debug render function for testing and development

    /**
     * Debug render a template with comprehensive logging and validation.
     * Delegates to: EnhancedTemplateEngine.debugRender()
     *
     * This public API wrapper creates a fresh template engine instance and
     * performs debug rendering with detailed console output. Features include:
     * - Logs input data and template name
     * - Validates template syntax before rendering
     * - Catches and logs errors gracefully (returns null on failure)
     * - Shows output preview in console
     * - Reports render duration and output length
     *
     * This is a development and debugging utility - use normal render() methods
     * for production. The method creates a new engine instance for each call
     * to ensure clean state for debugging.
     *
     * @param {string} templateName - Name of template to debug render
     * @param {Object} data - Data to pass to template (optional, defaults to empty object)
     * @returns {string|null} Rendered HTML on success, null on validation or render failure
     *
     * @example
     * // Debug render with logging
     * const html = TemplateSystem.debugRender('readingToolsSection', { fontSize: 1.2 });
     * // Console shows:
     * // === Debug render for template: readingToolsSection ===
     * // Input data: { fontSize: 1.2 }
     * // Render successful, length: 4523
     * // Output preview: <section id="reading-tools"...
     *
     * @example
     * // Debug render with validation failure
     * const html = TemplateSystem.debugRender('brokenTemplate');
     * // Console shows:
     * // [ERROR] Template validation failed: ['Mismatched {{#if}} tags']
     * // Returns: null
     */
    debugRender(templateName, data = {}) {
      const engine = new EnhancedTemplateEngine();
      return engine.debugRender(templateName, data);
    },

    // ===========================================================================================
    // PERFORMANCE MONITORING
    // ===========================================================================================
    // Track template rendering performance

    /**
     * Get comprehensive performance metrics for template rendering operations.
     * Delegates to: EnhancedTemplateEngine.getPerformanceReport()
     *
     * This public API method provides system-wide performance statistics from
     * the global performanceMetrics object. It creates a fresh engine instance
     * to access the shared metrics.
     *
     * The report includes:
     * - Average rendering time across all renders
     * - Total number of renders performed
     * - Cache hit rate (percentage of renders using compiled cache)
     * - Cache hits and misses counts
     * - Templates loaded in global cache
     * - Compiled templates count
     * - Global cache status
     *
     * Use this method to:
     * - Monitor template system performance
     * - Diagnose rendering bottlenecks
     * - Verify cache effectiveness
     * - Optimize template usage patterns
     *
     * @returns {Object} Performance metrics report
     * @returns {string} result.averageRenderTime - Average time per render (e.g., '2.45ms')
     * @returns {number} result.totalRenders - Total renders performed
     * @returns {string} result.cacheHitRate - Cache hit percentage (e.g., '94.3%')
     * @returns {number} result.cacheHits - Successful cache lookups
     * @returns {number} result.cacheMisses - Cache misses (compile required)
     * @returns {number} result.templatesLoaded - Templates in global cache
     * @returns {number} result.compiledTemplatesCount - Compiled templates cached
     * @returns {boolean} result.globalCacheLoaded - Global cache initialisation status
     * @returns {number} result.globalTemplatesCount - Total templates in global cache
     *
     * @example
     * const report = TemplateSystem.getPerformanceReport();
     * console.log('Performance Report:', report);
     * // {
     * //   averageRenderTime: '2.45ms',
     * //   totalRenders: 127,
     * //   cacheHitRate: '94.3%',
     * //   ...
     * // }
     *
     * @example
     * // Monitor cache effectiveness
     * const report = TemplateSystem.getPerformanceReport();
     * const hitRate = parseFloat(report.cacheHitRate);
     * if (hitRate < 80) {
     *   console.warn('Low cache hit rate - consider optimization');
     * }
     */
    getPerformanceReport() {
      const engine = new EnhancedTemplateEngine();
      return engine.getPerformanceReport();
    },

    // ===========================================================================================
    // TESTING & VALIDATION
    // ===========================================================================================
    // Development and testing utilities

    // Run basic template system tests
    /**
     * Run comprehensive template engine test suite - 17 test cases.
     * Delegates to: EnhancedTemplateEngine.test()
     *
     * This public API method runs the complete template system test suite,
     * validating all core functionality:
     * - Basic variable substitution and HTML escaping
     * - Control flow (if/else conditionals, each loops)
     * - Advanced features (partials, helpers, filters)
     * - Real-world templates (reading tools, theme toggle, MathJax)
     * - Performance validation (caching behaviour)
     * - British spelling helper
     * - Template syntax validation
     *
     * Each test is timed individually and results are aggregated. The method
     * creates a fresh engine instance to ensure clean test state.
     *
     * Test results include:
     * - Overall success status (all tests must pass)
     * - Individual test results with execution times
     * - Performance metrics (cache hit rate, render times)
     * - Total pass/fail statistics
     *
     * This is the primary validation method and should be run:
     * - After template system modifications
     * - During development (automatic in localhost)
     * - Before production deployments
     * - When troubleshooting issues
     *
     * @returns {Object} Test results object
     * @returns {boolean} result.success - True if all 17 tests passed
     * @returns {number} result.passed - Number of tests that passed
     * @returns {number} result.total - Total tests run (should be 17)
     * @returns {Array<Object>} result.results - Detailed results for each test with name, passed status, and duration
     * @returns {Object} result.performance - Performance metrics from test run
     *
     * @example
     * const results = TemplateSystem.test();
     * console.log(`Tests: ${results.passed}/${results.total} passed`);
     * // Console output:
     * // ‚úÖ Basic Variable Substitution: PASSED (0.23ms)
     * // ‚úÖ HTML Escaping: PASSED (0.18ms)
     * // ...
     * // üìä Template Engine Tests: 17/17 passed
     *
     * @example
     * // Check for failures
     * const results = TemplateSystem.test();
     * if (!results.success) {
     *   const failures = results.results.filter(r => !r.passed);
     *   console.error('Failed tests:', failures.map(f => f.name));
     * }
     */
    test() {
      const engine = new EnhancedTemplateEngine();
      return engine.test();
    },

    // ===========================================================================================
    // TEST FRAMEWORK COMPATIBILITY FUNCTIONS
    // ===========================================================================================

    /**
     * Validate template system integrity - Test framework compatibility wrapper.
     * Delegates to: EnhancedTemplateEngine.test() for validation tests
     *
     * This method provides a test-framework-friendly interface for template
     * system validation. It wraps the comprehensive test() method and returns
     * results in a format compatible with the testing framework expectations.
     *
     * The method:
     * - Checks global cache status and template availability
     * - Creates a fresh engine instance for validation
     * - Copies templates from global cache if needed
     * - Runs the full test suite (17 tests)
     * - Returns structured validation results
     * - Handles errors gracefully with detailed error messages
     *
     * Validation includes:
     * - Template syntax correctness
     * - Variable substitution functionality
     * - Control flow operations (if/else, each)
     * - Helper and filter functionality
     * - Real-world template rendering
     * - Performance metrics
     *
     * Return format matches test framework expectations:
     * - success/valid: Boolean pass/fail
     * - allPassed: Explicit boolean for framework
     * - passed/total: Test statistics
     * - errors: Array of error messages (empty if passed)
     * - warnings: Array of warning messages
     *
     * @returns {Object} Validation results object
     * @returns {boolean} result.success - True if all validation tests passed
     * @returns {boolean} result.valid - Alias for success (framework compatibility)
     * @returns {boolean} result.allPassed - Explicit pass status (framework compatibility)
     * @returns {number} result.passed - Number of tests passed
     * @returns {number} result.total - Total tests run
     * @returns {Array<string>} result.errors - Error messages (empty if passed)
     * @returns {Array<string>} result.warnings - Warning messages
     * @returns {number} result.templatesLoaded - Templates available for validation
     * @returns {Object} result.performanceMetrics - Performance report from validation
     *
     * @example
     * const validation = TemplateSystem.validateTemplateSystem();
     * if (validation.success) {
     *   console.log('‚úÖ Template system valid');
     * } else {
     *   console.error('‚ùå Validation errors:', validation.errors);
     * }
     *
     * @example
     * // Test framework usage
     * const validation = TemplateSystem.validateTemplateSystem();
     * assert.strictEqual(validation.allPassed, true);
     * assert.strictEqual(validation.errors.length, 0);
     */
    validateTemplateSystem() {
      logInfo("üß™ Running template system validation...");

      try {
        // ‚úÖ FIX: Synchronous validation using current template state
        // Templates should already be loaded or will use inline fallbacks
        logInfo("üîÑ Using current template state for validation...");

        const engine = new EnhancedTemplateEngine();

        // Check template availability
        const cacheStatus = this.getGlobalCacheStatus();
        logInfo(
          `üìä Template status: ${cacheStatus.templatesCount} templates available`
        );

        // If no templates in engine, try to copy from global cache
        if (engine.templates.size === 0 && cacheStatus.templatesCount > 0) {
          engine.copyFromGlobalCache();
          logInfo(
            `üìã Copied ${engine.templates.size} templates to validation engine`
          );
        }

        // Run validation tests
        const testResults = engine.test();

        const validation = {
          success: testResults.success,
          valid: testResults.success,
          errors: testResults.success
            ? []
            : testResults.results
                .filter((r) => !r.passed)
                .map((r) => r.error || `Test "${r.name}" failed`),
          warnings: [],
          templatesLoaded: engine.templates.size,
          performanceMetrics: engine.getPerformanceReport(),
          // ‚úÖ ADD: Explicit boolean for test framework
          allPassed: testResults.success,
          passed: testResults.passed || (testResults.success ? 1 : 0),
          total: testResults.total || 1,
        };

        logInfo(
          `‚úÖ Template validation complete: ${
            validation.success ? "PASSED" : "FAILED"
          }`
        );
        return validation;
      } catch (error) {
        logError("[TemplateSystem] ‚ùå Template validation failed:", error);
        return {
          success: false,
          valid: false,
          errors: [error.message],
          warnings: ["Template validation encountered an error"],
          allPassed: false,
          passed: 0,
          total: 1,
        };
      }
    },

    /**
     * Measure template rendering performance - Test framework compatibility wrapper.
     * Delegates to: EnhancedTemplateEngine.getPerformanceReport() for metrics
     *
     * This method provides a test-framework-friendly interface for performance
     * measurement. It wraps getPerformanceReport() and returns results in a
     * format optimized for performance testing and assertions.
     *
     * The method:
     * - Creates a fresh engine instance
     * - Retrieves current performance metrics
     * - Parses and formats timing data for framework consumption
     * - Calculates efficiency based on average render time (<5ms threshold)
     * - Extracts cache hit rate as numeric percentage
     * - Handles errors gracefully with high failure duration
     *
     * Performance metrics include:
     * - Average render time (parsed from 'X.XXms' to number)
     * - Efficiency status (true if average < 5ms)
     * - Total render count
     * - Cache hit rate (parsed from 'XX.X%' to number)
     * - Templates loaded count
     * - Raw performance report object
     *
     * Return format matches test framework expectations:
     * - duration: Numeric milliseconds for assertions
     * - efficient: Boolean for performance validation
     * - Additional metrics for detailed analysis
     *
     * @returns {Object} Performance measurement object
     * @returns {number} result.duration - Average render time in milliseconds
     * @returns {boolean} result.efficient - True if average render time < 5ms
     * @returns {number} result.totalRenders - Total number of renders performed
     * @returns {number} result.averageRenderTime - Average render time (same as duration)
     * @returns {number} result.cacheHitRate - Cache hit rate as numeric percentage
     * @returns {number} result.templatesLoaded - Number of templates loaded
     * @returns {Object} result.report - Full performance report object
     * @returns {string} [result.error] - Error message if measurement failed
     *
     * @example
     * const perf = TemplateSystem.measureTemplatePerformance();
     * console.log(`Average render: ${perf.duration.toFixed(2)}ms`);
     * console.log(`Efficient: ${perf.efficient}`);
     * console.log(`Cache hit rate: ${perf.cacheHitRate}%`);
     *
     * @example
     * // Test framework usage
     * const perf = TemplateSystem.measureTemplatePerformance();
     * assert.strictEqual(perf.efficient, true);
     * assert.isBelow(perf.duration, 5.0);
     */
    measureTemplatePerformance() {
      logInfo("üìä Measuring template performance...");

      try {
        const engine = new EnhancedTemplateEngine();
        const perfReport = engine.getPerformanceReport();

        // Parse average render time to get numeric duration
        const avgTimeStr = perfReport.averageRenderTime || "0ms";
        const duration = parseFloat(avgTimeStr.replace("ms", "")) || 0;

        const performanceData = {
          duration: duration,
          efficient: duration < 5.0, // Consider <5ms as efficient
          totalRenders: perfReport.totalRenders || 0,
          averageRenderTime: duration,
          cacheHitRate: parseFloat(
            (perfReport.cacheHitRate || "0%").replace("%", "")
          ),
          templatesLoaded: perfReport.templatesLoaded || 0,
          report: perfReport,
        };

        logInfo(
          `‚úÖ Performance measurement complete: ${duration.toFixed(
            2
          )}ms average`
        );
        return performanceData;
      } catch (error) {
        logError("[TemplateSystem] ‚ùå Performance measurement failed:", error);
        return {
          duration: 999,
          efficient: false,
          error: error.message,
        };
      }
    },
  };
  // Log successful loading
  logInfo("‚úÖ Enhanced Template System loaded successfully");
  logInfo(
    "üí° Commands: TemplateSystem.test() | TemplateSystem.getPerformanceReport()"
  );
  logInfo("üìù Templates use {{variable}} syntax with caching for performance");

  // Return the TemplateSystem for the IIFE
  return TemplateSystem;
})();

// Make globally available AFTER the IIFE completes
window.TemplateSystem = TemplateSystem;

// Also export for ES6 module compatibility
if (typeof module !== "undefined" && module.exports) {
  module.exports = TemplateSystem;
}

// Auto-run tests in development - with proper template loading wait
if (
  window.location.hostname === "localhost" ||
  window.location.hostname === "127.0.0.1"
) {
  console.log(
    "üöÄ Development mode detected - running template engine tests..."
  );

  // ‚úÖ PHASE 5.6 FIX: Wait for global template cache to be loaded
  async function runDevelopmentTests() {
    if (window.TemplateSystem) {
      try {
        // Wait for global template cache to be loaded
        const cacheStatus = window.TemplateSystem.getGlobalCacheStatus();
        if (!cacheStatus.isLoaded) {
          console.log("‚è≥ Waiting for template cache to load...");
          await window.TemplateSystem.ensureTemplatesLoaded();
        }

        // Now run tests with templates guaranteed to be loaded
        console.log("‚úÖ Template cache loaded, running development tests...");
        window.TemplateSystem.test();
      } catch (error) {
        console.error("‚ùå Development test failed:", error.message);
      }
    }
  }

  // Small delay to ensure TemplateSystem is available, then wait for templates
  setTimeout(runDevelopmentTests, 1500);
}
